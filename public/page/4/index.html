<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://vissssa.club').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: '',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="python, flask, linux, 架构, 生活, 科技">
<meta name="keywords" content="python, flask, linux, 架构, 生活, 科技">
<meta property="og:type" content="website">
<meta property="og:title" content="vissssa">
<meta property="og:url" content="http:&#x2F;&#x2F;vissssa.club&#x2F;page&#x2F;4&#x2F;index.html">
<meta property="og:site_name" content="vissssa">
<meta property="og:description" content="python, flask, linux, 架构, 生活, 科技">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://vissssa.club/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>vissssa</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">vissssa</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">我的一些笔记，人生感悟、读后感、开箱评测等</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://vissssa.club/2019/05/15/%E9%A2%98%E7%9B%AE%E4%B8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vissssa">
      <meta itemprop="description" content="python, flask, linux, 架构, 生活, 科技">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="vissssa">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/15/%E9%A2%98%E7%9B%AE%E4%B8%80/" class="post-title-link" itemprop="url">题目一</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-15 00:00:00" itemprop="dateCreated datePublished" datetime="2019-05-15T00:00:00+08:00">2019-05-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-28 15:18:14" itemprop="dateModified" datetime="2019-11-28T15:18:14+08:00">2019-11-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/interview/" itemprop="url" rel="index">
                    <span itemprop="name">interview</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p> 【题目:001】| 说说你对zen of python的理解，你有什么办法看到它?</p>
<p>Python之禅,Python秉承一种独特的简洁和可读行高的语法，以及高度一致的编程模式，符合“大脑思维习惯”，使Python易于学习、理解和记忆。Python同时采用了一条极简主义的设计理念，了解完整的Python哲学理念，可以在任何一个Python交互解释器中键入import this命令，这是Python隐藏的一个彩蛋:描绘了一系列Python设计原则。如今已是Python社区内流行的行话”EIBTI”，明了胜于晦涩这条规则的简称. 在Python的思维方式中，明了胜于晦涩，简洁胜于复杂。</p>
<pre><code>&gt;&gt;&gt; import this
The Zen of Python, by Tim Peters

Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren&apos;t special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one-- and preferably only one --obvious way to do it.
Although that way may not be obvious at first unless you&apos;re Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it&apos;s a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea -- let&apos;s do more of those!</code></pre><p>【题目:002】| 说说你对pythonic的看法，尝试解决下面的小问题</p>
<p>#简洁，明了，严谨，灵活</p>
<pre><code>#交换两个变量值
a,b = b,a

#去掉list中的重复元素
old_list = [1,1,1,3,4]
new_list = list(set(old_list))

#翻转一个字符串
s = &apos;abcde&apos;
ss = s[::-1]

#用两个元素之间有对应关系的list构造一个dict
names = [&apos;jianpx&apos;, &apos;yue&apos;]
ages = [23, 40]
m = dict(zip(names,ages))

#将数量较多的字符串相连，如何效率较高，为什么
fruits = [&apos;apple&apos;, &apos;banana&apos;]
result = &apos;&apos;.join(fruits)

#python字符串效率问题之一就是在连接字符串的时候使用‘+’号，例如 s = ‘s1’ + ‘s2’ + ‘s3’ + ...+’sN’，总共将N个字符串连接起来， 但是使用+号的话，python需要申请N-1次内存空间， 然后进行字符串拷贝。原因是字符串对象PyStringObject在python当中是不可变 对象，所以每当需要合并两个字符串的时候，就要重新申请一个新的内存空间 （大小为两个字符串长度之和）来给这个合并之后的新字符串，然后进行拷贝。 所以用+号效率非常低。建议在连接字符串的时候使用字符串本身的方法 join（list），这个方法能提高效率，原因是它只是申请了一次内存空间， 因为它可以遍历list中的元素计算出总共需要申请的内存空间的大小，一次申请完。</code></pre><p>【题目:003】| 你调试python代码的方法有哪些?</p>
<pre><code>具体IDE都有调试，比如:IDLE, Eclipse+Pydev都可以设置断点调试。
pdb模块也可以做调试。
还有PyChecker和Pylint
PyChecker是一个python代码的静态分析工具，它可以帮助查找python代码的bug, 会对代码的复杂度和格式提出警告
Pylint   是另外一个工具可以进行coding standard检查。</code></pre><p>【题目:004】|  你在github上都fork过哪些python库，列举一下你经常使用的，每个库用一句话描述下其功能</p>
<pre><code>http://rogerdudler.github.io/git-guide/index.zh.html    #关于git简明指南
http://www.zhihu.com/question/20070065                  #关于git的BBS
http://www.techug.com/githug-for-designer               #关于github的</code></pre><p>【题目:005】|  什么是GIL?</p>
<pre><code>什么是GIL(Global Interpreter Lock)全局解释器锁? 简单地说就是:
每一个interpreter进程,只能同时仅有一个线程来执行, 获得相关的锁, 存取相关的资源.
那么很容易就会发现,如果一个interpreter进程只能有一个线程来执行,
多线程的并发则成为不可能, 即使这几个线程之间不存在资源的竞争.
从理论上讲,我们要尽可能地使程序更加并行, 能够充分利用多核的功能.</code></pre><p>【题目:006】|  什么是元类(meta_class)?</p>
<pre><code>元类就是用来创建类的“东西”
详情操作: http://blog.jobbole.com/21351/</code></pre><p>【题目:007】|  对比一下dict中items与iteritems?</p>
<pre><code>&gt;&gt;&gt; D = {&apos;a&apos;:1,&apos;b&apos;:2,&apos;c&apos;:3,&apos;d&apos;:4}
&gt;&gt;&gt; D.items()                       #一次性取出所有
[(&apos;a&apos;, 1), (&apos;c&apos;, 3), (&apos;b&apos;, 2), (&apos;d&apos;, 4)]
&gt;&gt;&gt; D.iteritems()                   #迭代对象，每次取出一个。用for循环遍历出来；
&lt;dictionary-itemiterator object at 0x00000000026243B8&gt;
&gt;&gt;&gt; for i in D.iteritems():
...   print i,
...
(&apos;a&apos;, 1) (&apos;c&apos;, 3) (&apos;b&apos;, 2) (&apos;d&apos;, 4)
&gt;&gt;&gt; for k,v in D.iteritems():
...   print k,
...
a c b d
总结:
1. 一般iteritems()迭代的办法比items()要快，特别是数据库比较大时。
2. 在Python3中一般取消前者函数</code></pre><p>【题目:008】|  是否遇到过python的模块间循环引用的问题，如何避免它?</p>
<pre><code>这是代码结构设计的问题，模块依赖和类依赖
如果老是觉得碰到循环引用，很可能是模块的分界线划错地方了。可能是把应该在一起的东西硬拆开了，可能是某些职责放错地方了，可能是应该抽象的东西没抽象
总之微观代码规范可能并不能帮到太多，重要的是更宏观的划分模块的经验技巧，推荐uml，脑图，白板等等图形化的工具先梳理清楚整个系统的总体结构和职责分工

采取办法，从设计模式上来规避这个问题，比如:
1. 使用 “__all__” 白名单开放接口
2. 尽量避免 import</code></pre><p>【题目:009】|  有用过with statement吗？它的好处是什么？</p>
<pre><code>&gt;&gt;&gt; with open(&apos;text.txt&apos;) as myfile:
...   while True:
...     line = myfile.readline()
...     if not line:
...       break
...     print line,

# with语句使用所谓的上下文管理器对代码块进行包装，允许上下文管理器实现一些设置和清理操作。
# 例如：文件可以作为上下文管理器使用，它们可以关闭自身作为清理的一部分。
# NOTE：在PYTHON2.5中，需要使用from __future__ import with_statement进行with语句的导入</code></pre><p>【题目:010】|用Python生成指定长度的斐波那契数列</p>
<pre><code>def fibs(x):
    result = [0, 1]
    for index in range(x-2):
        result.append(result[-2]+result[-1])
    return result

if __name__==&apos;__main__&apos;:
    num = input(&apos;Enter one number: &apos;)
    print fibs(num)</code></pre><p>【题目:011】|  Python里如何生产随机数</p>
<pre><code>&gt;&gt;&gt; import random
&gt;&gt;&gt; random.random()
0.29495314937268713
&gt;&gt;&gt; random.randint(1,11)
8
&gt;&gt;&gt; random.choice(range(11))
3</code></pre><p>【题目:012】|  Python里如何反序的迭代一个序列</p>
<pre><code>如果是一个list, 最快的解决方案是：

list.reverse()
try:
    for x in list:
        “do something with x”
finally:
    list.reverse()

如果不是list, 最通用但是稍慢的解决方案是：
for i in range(len(sequence)-1, -1, -1):
x = sequence[i]</code></pre><p>【题目:013】|  Python中如何定义一个函数</p>
<pre><code>def func(arg, *args, **kwagrs):   #普通函数
    func_body
    return

lambda x: x **2                   #匿名函数</code></pre><p>【题目:014】|  Python匹配HTML tag的时候，&lt;.<em>&gt;和&lt;.</em>?&gt;有什么区别</p>
<pre><code>import re
s = ‘&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;’
print(re.match(‘&lt;.*&gt;’, s).group())

会返回一个匹配&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;而不是&lt;html&gt;

而

import re
s = ‘&lt;html&gt;&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;’
print(re.match(‘&lt;.*?&gt;’, s).group())

则会返回&lt;html&gt;

&lt;.*&gt;这种匹配称作贪心匹配 &lt;.*?&gt;称作非贪心匹配</code></pre><p>【题目:015】|  Python里面search()和match()的区别</p>
<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; re.match(r&apos;python&apos;,&apos;Programing Python, should be pythonic&apos;)
&gt;&gt;&gt; obj1 = re.match(r&apos;python&apos;,&apos;Programing Python, should be pythonic&apos;)  #返回None
&gt;&gt;&gt; obj2 = re.search(r&apos;python&apos;,&apos;Programing Python, should be pythonic&apos;) #找到pythonic
&gt;&gt;&gt; obj2.group()
&apos;python&apos;
#re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；
#re.search匹配整个字符串，直到找到一个匹配。</code></pre><p>【题目:016】|  Python程序中文输出问题怎么解决</p>
<pre><code>在Python3中，对中文进行了全面的支持，但在Python2.x中需要进行相关的设置才能使用中文。否则会出现乱码。
Python默认采取的ASCII编码，字母、标点和其他字符只使用一个字节来表示，但对于中文字符来说，一个字节满足不了需求。
为了能在计算机中表示所有的中文字符，中文编码采用两个字节表示。如果中文编码和ASCII混合使用的话，就会导致解码错误，从而才生乱码。
解决办法:
交互式命令中：一般不会出现乱码，无需做处理
py脚本文件中：跨字符集必须做设置，否则乱码
1. 首先在开头一句添加:
# coding = utf-8
# 或
# coding = UTF-8
# 或
# -*- coding: utf-8 -*-
2. 其次需将文件保存为UTF-8的格式！
3. 最后: s.decode(&apos;utf-8&apos;).encode(&apos;gbk&apos;)</code></pre><p>【题目:017】|  什么是lambda函数</p>
<pre><code>函数使用:
1. 代码块重复，这时候必须考虑到函数，降低程序的冗余度
2. 代码块复杂，这时候必须考虑到函数，降低程序的复杂度
Python有两种函数,一种是def定义，一种是lambda函数()
当程序代码很短，且该函数只使用一次，为了程序的简洁，及节省变量内存占用空间，引入了匿名函数这个概念
&gt;&gt;&gt; nums = range(2,20)
&gt;&gt;&gt; for i in nums:
        nums = filter(lambda x:x==i or x % i,nums)
&gt;&gt;&gt; nums
[2, 3, 5, 7, 11, 13, 17, 19]</code></pre><p>【题目:018】|  Python里面如何实现tuple和list的转换</p>
<pre><code>#From list to Tuple
tuple(a_list)

#From Tuple to List
def to_list(t):
    return [i if not isinstance(i,tuple) else to_list(i) for i in t]</code></pre><p>【题目:019】|  请写出一段Python代码实现删除一个list里面的重复元素</p>
<pre><code>&gt;&gt;&gt; L1 = [4,1,3,2,3,5,1]
&gt;&gt;&gt; L2 = []
&gt;&gt;&gt; [L2.append(i) for i in L1 if i not in L2]
&gt;&gt;&gt; print L2
[4, 1, 3, 2, 5]</code></pre><p>【题目:020】|  Python是如何进行类型转换的</p>
<pre><code>&gt;&gt;&gt; int(&apos;1234&apos;)                   # 将数字型字符串转为整形
1234
&gt;&gt;&gt; float(12)                     # 将整形或数字字符转为浮点型
12.0
&gt;&gt;&gt; str(98)                       # 将其他类型转为字符串型
&apos;98&apos;
&gt;&gt;&gt; list(&apos;abcd&apos;)                  # 将其他类型转为列表类型
[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;]
&gt;&gt;&gt; dict.fromkeys([&apos;name&apos;,&apos;age&apos;]) # 将其他类型转为字典类型
{&apos;age&apos;: None, &apos;name&apos;: None}
&gt;&gt;&gt; tuple([1, 2, 3, 4])           # 将其他类型转为元祖类型
(1, 2, 3, 4)</code></pre><p>详细转换总结如下:</p>
<pre><code>函数                      描述
int(x [,base])              将x转换为一个整数
long(x [,base] )            将x转换为一个长整数
float(x)                    将x转换到一个浮点数
complex(real [,imag])       创建一个复数
str(x)                      将对象 x 转换为字符串
repr(x)                     将对象 x 转换为表达式字符串
eval(str)                   用来计算在字符串中的有效Python表达式,并返回一个对象
tuple(s)                    将序列 s 转换为一个元组
list(s)                     将序列 s 转换为一个列表
set(s)                      转换为可变集合
dict(d)                     创建一个字典。d 必须是一个序列 (key,value)元组。
frozenset(s)                转换为不可变集合
chr(x)                      将一个整数转换为一个字符
unichr(x)                   将一个整数转换为Unicode字符
ord(x)                      将一个字符转换为它的整数值
hex(x)                      将一个整数转换为一个十六进制字符串
oct(x)                      将一个整数转换为一个八进制字符串</code></pre><p>【题目:021】|  如何知道一个Python对象的类型</p>
<pre><code>&gt;&gt;&gt; type([]);type(&apos;&apos;);type(0);type({});type(0.0);type((1,))
&lt;type &apos;list&apos;&gt;
&lt;type &apos;str&apos;&gt;
&lt;type &apos;int&apos;&gt;
&lt;type &apos;dict&apos;&gt;
&lt;type &apos;float&apos;&gt;
&lt;type &apos;tuple&apos;&gt;</code></pre><p>【题目:022】|  Python里面如何拷贝一个对象</p>
<pre><code>切片S[:]  # 注不能应用于字典
深浅宝贝  # 能应用于所有序列和字典
1. 浅拷贝D.copy()方法
2. 深拷贝deepcopy(D)方法</code></pre><p>【题目:023】|  Python中pass语句的作用是什么</p>
<pre><code>pass语句什么也不做,一般作为占位符或者创建占位程序</code></pre><p>【题目:024】|  写一段程序逐行读入一个文本文件，并在屏幕上打印出来</p>
<pre><code>f = open(filename)
while True:
    line = f.readline()
    if not line: break
    print(line)
f.close()</code></pre><p>【题目:025】|  如何用Python删除一个文件</p>
<pre><code>import os
os.remove(filename)</code></pre><p>【题目:026】|  Python代码得到列表list的交集与差集</p>
<pre><code>&gt;&gt;&gt; list1 = [1, 3, 4, 6]
&gt;&gt;&gt; list2 = [1, 2, 3, 4]
&gt;&gt;&gt; [i for i in list1 if i not in list2]
[6]
&gt;&gt;&gt; [i for i in list1 if i in list2]
[1, 3, 4]</code></pre><p>【题目:027】|  Python是如何进行内存管理的</p>
<pre><code>python内部使用引用计数，来保持追踪内存中的对象，Python内部记录了对象有多少个引用，即引用计数，当对象被创建时就创建了一个引用计数，当对象不再需要时，这个对象的引用计数为0时，它被垃圾回收。所有这些都是自动完成，不需要像C一样，人工干预，从而提高了程序员的效率和程序的健壮性。</code></pre><p>【题目:028】|  介绍一下Python下range()函数的用法</p>
<pre><code>&gt;&gt;&gt; range(10)
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
&gt;&gt;&gt; range(1, 10)
[1, 2, 3, 4, 5, 6, 7, 8, 9]
&gt;&gt;&gt; range(0, 9, 2)
[0, 2, 4, 6, 8]
&gt;&gt;&gt; range(99,0,-10)
[99, 89, 79, 69, 59, 49, 39, 29, 19, 9]
相区别的是xrange(),每次只取出一个迭代对象，如果是数据量比较大时，效率较高
在Python3中，没有xrange()函数，其功能放在了range()函数上</code></pre><p>【题目:029】|  Python异常处理介绍一下</p>
<pre><code>程序中出现异常情况时就需要异常处理。比如当你打开一个不存在的文件时。当你的程序中有
一些无效的语句时，Python会提示你有错误存在。下面是一个拼写错误的例子，print写成了Print
下面是异常最常见的几种角色
1. 错误处理
&gt;&gt;&gt;可以在程序代码中捕捉和相应错误，或者忽略已发生的异常。
&gt;&gt;&gt;如果忽略错误，PYTHON默认的异常处理行为将启动:停止程序，打印错误信息。
&gt;&gt;&gt;如果不想启动这种默认行为，就用try语句来捕捉异常并从异常中恢复。
2. 事件通知
&gt;&gt;&gt;异常也可用于发出有效状态的信号，而不需在程序间传递结果标志位。或者刻意对其进行测试
3. 特殊情况处理
&gt;&gt;&gt;有时，发生了某种很罕见的情况，很难调整代码区处理。通常会在异常处理中处理，从而省去应对特殊情况的代码
4. 终止行为
&gt;&gt;&gt;try/finally语句可确保一定会进行需要的结束运算，无论程序是否有异常
5. 非常规控制流程</code></pre><p>【题目:030】|  介绍一下Python中的filter方法</p>
<pre><code>filter就像map,reduce,apply,zip等都是内置函数，用C语言实现，具有速度快，功能强大等

优点。
用于过滤与函数func()不匹配的值, 类似于SQL中select value != &apos;a&apos;
相当于一个迭代器，调用一个布尔函数func来迭代seq中的每个元素，返回一个是bool_seq返

回为True的序列
&gt;&gt;&gt;第一个参数: function or None, 函数或None
&gt;&gt;&gt;第二个参数: sequence,序列</code></pre><p>【题目:031】|  介绍一下except的用法和作用</p>
<pre><code>try/except:          捕捉由PYTHON自身或写程序过程中引发的异常并恢复
except:              捕捉所有其他异常
except name:         只捕捉特定的异常
except name, value:  捕捉异常及格外的数据(实例)
except (name1,name2) 捕捉列出来的异常
except (name1,name2),value: 捕捉任何列出的异常，并取得额外数据
else:                如果没有引发异常就运行
finally:             总是会运行此处代码</code></pre><p>【题目:032】|  如何用Python来进行查询和替换一个文本字符串</p>
<pre><code>&gt;&gt;&gt; words = &apos;Python is a very funny language!&apos;
&gt;&gt;&gt; words.find(&apos;Python&apos;)             # 返回的为0或正数时，为其索引号
0
&gt;&gt;&gt; words.find(&apos;is&apos;)
7
&gt;&gt;&gt; words.find(&apos;dafa&apos;)               # 返回-1表示查找失败
-1
&gt;&gt;&gt; words.replace(&apos;Python&apos;, &apos;Perl&apos;)  # replace()替换
&apos;Perl is a very funny language!&apos;</code></pre><p>【题目:033】|  Python如何copy一个文件</p>
<pre><code>import shutil
shutil.copyfile(&apos;a.py&apos;, &apos;copy_a.py&apos;)</code></pre><p>【题目:034】|  Python判断当前用户是否是root</p>
<pre><code>import os
if os.getuid() != 0:    # root账号的uid=0
    print os.getuid()
    print &apos;Should run as root account&apos;
else:
    print &apos;Hello, Root!&apos;</code></pre><p>【题目:035】|  用Python写一个for循环的例子</p>
<pre><code>for循环可以遍历序列(列表，字符串，元祖),range()及迭代对象，如xrange()
names = [&apos;Alice&apos;, &apos;Betty&apos;, &apos;Fred&apos;, &apos;Tom&apos;]
for index, name in enumerate(names):
    print &apos;index:&apos;,index,&apos;=&gt;&apos;, name

# 输出结果
index: 0 =&gt; Alice
index: 1 =&gt; Betty
index: 2 =&gt; Fred
index: 3 =&gt; Tom</code></pre><p>【题目:036】|  介绍一下Python中webbrowser的用法</p>
<pre><code>webbrowser模块提供了一个高级接口来显示基于Web的文档，大部分情况下只需要简单的调用open()方法。

webbrowser定义了如下的异常：exception webbrowser.Error, 当浏览器控件发生错误是会抛出这个异常

webbrowser有以下方法：

webbrowser.open(url[, new=0[, autoraise=1]])

这个方法是在默认的浏览器中显示url, 如果new = 0, 那么url会在同一个浏览器窗口下打开，如果new = 1, 会打开一个新的窗口，如果new = 2, 会打开一个新的tab, 如果autoraise ＝ true, 窗口会自动增长。

webbrowser.open_new(url)
在默认浏览器中打开一个新的窗口来显示url, 否则，在仅有的浏览器窗口中打开url

webbrowser.open_new_tab(url)
在默认浏览器中当开一个新的tab来显示url, 否则跟open_new()一样

webbrowser.get([name]) 根据name返回一个浏览器对象，如果name为空，则返回默认的浏览器

webbrowser.register(name, construtor[, instance])
注册一个名字为name的浏览器，如果这个浏览器类型被注册就可以用get()方法来获取。</code></pre><p>【题目:037】|  默写尽可能多的str对象的方法</p>
<pre><code>#方法                                   #描述
-------------------------------------------------------------------------------------------------
S.capitalize()                          #返回首字母大写的字符串的副本
S.center(width[,fillchar])              #返回一个长度为max(len(S),width),S居中，两侧fillchar填充
S.count(sub[,start[,end]])              #计算子字符串sub的出现次数，可将搜索范围限制为S[start:end]
S.decode([encoding[,error]])            #返回使用给定编码方式的字符串的解码版本，由error指定错误处理方式
S.endswith(suffix[start[,end]])         #检查S是否以suffix结尾，可给定[start:end]来选择匹配的范围
S.expandtabs([tabsize])                 #返回字符串的副本，其中tab字符会使用空格进行扩展，可选择tabsize
S.find(sun[,start[,end]])               #返回子字符串sub的第一个索引，不存在则为-1,可选择搜索范围
S.index(sub[,start[,end]])              #返回子字符串sub的第一个索引，不存在则引发ValueError异常.
S.isalnum()                             #检查字符串是否由字母或数字字符组成
S.isalpha()                             #检查字符串是否由字母字符组成
S.isdigit()                             #检查字符串是否由数字字符组成
S.islower()                             #检查字符串是否由小写字母组成
S.isspace()                             #检查字符串是否由空格组成
S.istitle()                             #检查字符串时候首字母大写
S.isupper()                             #检查字符串是否由大写字母组成
S.join(sequence)                        #返回其中sequence的字符串元素由S连接的字符串
S.ljust(width[,fillchar])               #返回S副本左对齐的字符串,长度max(len(S),W),右侧fillchar填充
S.lower()                               #返回所有字符串都为小写的副本
S.lstrip([char])                        #向左移除所有char，默认移除(空格,tab,\n)
S.partition(seq)                        #在字符串中搜索seq并返回
S.replace(old,new[,max])                #将new替换olad,最多可替换max次
S.rfind(sub[,start[,end]])              #返回sub所在的最后一个索引，不存在则为-1,可定搜索范围S[start:end]
S.rindex(sub[,start[,end]])             #返回sub所在的最后一个索引，不存在则会引发ValueError异常。
S.rjust(width[,fillchar])               #返回S副本右对齐的字符串,长度max(len(S),W),左侧fillchar填充
S.rpartition(seq)                       #同Partition,但从右侧开始查找
S.rstip([char])                         #向右移除所有char，默认移除(空格,tab,\n)
S.rsplit(sep[,maxsplit])                #同split,但是使用maxsplit时是从右往左进行计数
S.split(sep[,maxsplit])                 #使用sep做为分割符,可使用maxsplit指定最大切分数
S.zfill(width)                          #在S的左侧以0填充width个字符
S.upper()                               #返回S的副本，所有字符大写
S.splitlines([keepends])                #返回S中所有行的列表，可选择是否包括换行符
S.startswith(prefix[,start[,end]])      #检查S是否以prefix开始，可用[start,end]来定义范围
S.strip([chars])                        #移除所有字符串中含chars的字符，默认移除(空格，tab,\n)
S.swapcase()                            #返回S的副本，所有大小写交换
S.title()                               #返回S的副本，所有单词以大写字母开头
S.translate(table[,deletechars])        #返回S的副本，所有字符都使用table进行的转换，可选择删除出现在deletechars中的所有字符</code></pre><p>【题目:038】|  现在有一个dict对象adict,里面包含了一百万个元素,查找其中的某个元素的平均需要多少次比较</p>
<pre><code>O(1)  哈希字典，快速查找，键值映射，键唯一!</code></pre><p>【题目:039】|  有一个list对象alist，里面的所有元素都是字符串，编写一个函数对它实现一个大小写无关的排序</p>
<pre><code>words = [&apos;This&apos;,&apos;is&apos;,&apos;a&apos;,&apos;dog&apos;,&apos;!&apos;]
words.sort(key=lambda x:x.lower())
print words
#输出结果
&gt;&gt;&gt;
[&apos;!&apos;, &apos;a&apos;, &apos;dog&apos;, &apos;is&apos;, &apos;This&apos;]</code></pre><p>【题目:040】|  有一个排好序地list对象alist，查找其中是否有某元素a</p>
<pre><code>alist = [&apos;a&apos;,&apos;s&apos;,&apos;d&apos;,&apos;f&apos;]

try:
    alist.index(&apos;a&apos;)
    print &apos;Find it.&apos;
except ValueError:
    print &apos;Not Found.&apos;</code></pre><p>【题目:041】|  请用Python写一个获取用户输入数字，并根据数字大小输出不同信息的脚本</p>
<pre><code>num = input(&apos;Enter number: &apos;)

if num &gt; 100:
    print &apos;The number is over 100&apos;
elif 0 &lt; num &lt;= 100:
    print &apos;The number is between 0~100&apos;
elif num &lt; 0:
    print &apos;The number is negative.&apos;
else:
    print &apos;Not a number&apos;</code></pre><p>【题目:042】|  打乱一个排好序的list对象alist</p>
<pre><code># random模块中的shuffle(洗牌函数)
import random
alist = [1, 2, 3, 4]
random.shuffle(alist)
print alist</code></pre><p>【题目:043】|  有二维的list对象alist，假定其中的所有元素都具有相同的长度，写一段程序根据元素的第二个元素排序</p>
<pre><code>def sort_lists(lists, sord, idx):
    if sord == &apos;desc&apos;:
        lists.sort(key=lambda x:x[idx], reverse=True)
    else:
        lists.sort(key=lambda x:x[idx])
    return lists
lists = [[&apos;cd&apos;,&apos;ab&apos;],[&apos;ef&apos;,&apos;ac&apos;]]
sort_lists(lists,&apos;desc&apos;,1)
print lists

# 输出结果
&gt;&gt;&gt;
[[&apos;ef&apos;, &apos;ac&apos;], [&apos;cd&apos;, &apos;ab&apos;]]</code></pre><p>【题目:044】|  inspect模块有什么用</p>
<pre><code>inspect模块提供了一系列函数用于帮助使用自省。

检查对象类型
is{module|class|function|method|builtin}(obj): 检查对象是否为模块、类、函数、方法、内建函数或方法。
isroutine(obj): 用于检查对象是否为函数、方法、内建函数或方法等等可调用类型。

获取对象信息
getmembers(object[, predicate]): 这个方法是dir()的扩展版，它会将dir()找到的名字对应的属性一并返回。
getmodule(object): 它返回object的定义所在的模块对象。
get{file|sourcefile}(object): 获取object的定义所在的模块的文件名|源代码文件名（如果没有则返回None）。
get{source|sourcelines}(object): 获取object的定义的源代码，以字符串|字符串列表返回。
getargspec(func): 仅用于方法，获取方法声明的参数，返回元组，分别是(普通参数名的列表, *参数名, **参数名, 默认值元组)。</code></pre><p>【题目:045】|  Python处理命令行参数示例代码</p>
<pre><code># 最简单、最原始的方法就是手动解析了
import sys
for arg in sys.argv[1:]:
    print(arg)</code></pre><p>【题目:046】|  介绍一下Python getopt模块</p>
<pre><code># getopt模块是原来的命令行选项解析器，支持UNIX函数getopt()建立的约定。
# 它会解析一个参数序列，如sys.argv，并返回一个元祖序列和一个非选项参数序列。
# 目前支持的选项语法包括短格式和长格式选项：-a, -bval, -b val, --noarg, --witharg=val, --witharg val。
# 如果只是简单的命令行解析，getopt还是不错的选择。一个例子如下

import sys
import getopt

try:
    options, remainder = getopt.getopt(sys.argv[1:], &apos;o:v&apos;, [&apos;output=&apos;, &apos;verbose&apos;, &apos;version=&apos;,])
except getopt.GetoptError as err:
    print &apos;ERROR:&apos;, err
    sys.exit(1)
总结下getopt的特点：1.  getopt是从前到后解析 2.  getopt不检查额外参数的合法性，需要自行检查           3.  短命令行和长命令行是分开解析的&lt;/span&gt;</code></pre><p>【题目:047】|  Python列表与元组的区别是什么？分别在什么情况下使用？</p>
<pre><code>Python中列表和元祖都是序列，因此都能进行添加，删除，更新，切片等操作。但列表是可变对象，元祖是不可变对象。
元祖主要用于函数赋值，字符串格式化等。但列表中的方法更多些，也是PYTHON中更常用的数据结构。</code></pre><p>【题目:048】|  有一个长度是101的数组，存在1~100的数字，有一个是重复的，拿重复的找出来</p>
<pre><code># Python中，主要是拿count(i) ==2的找出来即可，再利用列表推导式
&gt;&gt;&gt; l = [1, 2, 3, 4, 2]
&gt;&gt;&gt; tmp = []
&gt;&gt;&gt; [tmp.append(i) for i in l if l.count(i) == 2]
[None, None]
&gt;&gt;&gt; tmp
[2, 2]
&gt;&gt;&gt; set(tmp)
set([2])</code></pre><p>【题目:049】|  set是在哪个版本成为build-in types的？举例说明,并说明为什么当时选择了set这种数据结构</p>
<pre><code>python的set和其他语言类似, 是一个无序不重复元素集, 基本功能包括关系测试和消除重复元素. 集合对象还支持union(联合), intersection(交), difference(差)和sysmmetric difference(对称差集)等数学运算.

sets 支持 x in set, len(set),和 for x in set。作为一个无序的集合，sets不记录元素位置或者插入点。因此，sets不支持 indexing, slicing, 或其它类序列（sequence-like）的操作。


下面来点简单的小例子说明。

&gt;&gt;&gt; x = set(&apos;spam&apos;)
&gt;&gt;&gt; y = set([&apos;h&apos;,&apos;a&apos;,&apos;m&apos;])
&gt;&gt;&gt; x, y
(set([&apos;a&apos;, &apos;p&apos;, &apos;s&apos;, &apos;m&apos;]), set([&apos;a&apos;, &apos;h&apos;, &apos;m&apos;]))

再来些小应用。

&gt;&gt;&gt; x &amp; y # 交集
set([&apos;a&apos;, &apos;m&apos;])

&gt;&gt;&gt; x | y # 并集
set([&apos;a&apos;, &apos;p&apos;, &apos;s&apos;, &apos;h&apos;, &apos;m&apos;])

&gt;&gt;&gt; x - y # 差集
set([&apos;p&apos;, &apos;s&apos;])

去除海量列表里重复元素，用hash来解决也行，只不过感觉在性能上不是很高，用set解决还是很不错的，示例如下：

&gt;&gt;&gt; a = [11,22,33,44,11,22]
&gt;&gt;&gt; b = set(a)
&gt;&gt;&gt; b
set([33, 11, 44, 22])
&gt;&gt;&gt; c = [i for i in b]
&gt;&gt;&gt; c
[33, 11, 44, 22]

很酷把，几行就可以搞定。

1.8　集合

集合用于包含一组无序的对象。要创建集合，可使用set()函数并像下面这样提供一系列的项：
s = set([3,5,9,10])      #创建一个数值集合
t = set(&quot;Hello&quot;)         #创建一个唯一字符的集合

与列表和元组不同，集合是无序的，也无法通过数字进行索引。此外，集合中的元素不能重复。例如，如果检查前面代码中t集合的值，结果会是：



&gt;&gt;&gt; t
set([&apos;H&apos;, &apos;e&apos;, &apos;l&apos;, &apos;o&apos;])
注意只出现了一个&apos;l&apos;。

集合支持一系列标准操作，包括并集、交集、差集和对称差集，例如：
a = t | s          # t 和 s的并集
b = t &amp; s          # t 和 s的交集
c = t – s         # 求差集（项在t中，但不在s中）
d = t ^ s          # 对称差集（项在t或s中，但不会同时出现在二者中）



基本操作：

t.add(&apos;x&apos;)            # 添加一项
s.update([10,37,42])  # 在s中添加多项



使用remove()可以删除一项：
t.remove(&apos;H&apos;)

len(s)
set 的长度

x in s
测试 x 是否是 s 的成员

x not in s
测试 x 是否不是 s 的成员

s.issubset(t)
s &lt;= t
测试是否 s 中的每一个元素都在 t 中

s.issuperset(t)
s &gt;= t
测试是否 t 中的每一个元素都在 s 中

s.union(t)
s | t
返回一个新的 set 包含 s 和 t 中的每一个元素

s.intersection(t)
s &amp; t
返回一个新的 set 包含 s 和 t 中的公共元素

s.difference(t)
s - t
返回一个新的 set 包含 s 中有但是 t 中没有的元素

s.symmetric_difference(t)
s ^ t
返回一个新的 set 包含 s 和 t 中不重复的元素

s.copy()
返回 set “s”的一个浅复制


请注意：union(), intersection(), difference() 和 symmetric_difference() 的非运算符（non-operator，就是形如 s.union()这样的）版本将会接受任何 iterable 作为参数。相反，它们的运算符版本（operator based counterparts）要求参数必须是 sets。这样可以避免潜在的错误，如：为了更可读而使用 set(&apos;abc&apos;) &amp; &apos;cbs&apos; 来替代 set(&apos;abc&apos;).intersection(&apos;cbs&apos;)。从 2.3.1 版本中做的更改：以前所有参数都必须是 sets。

另外，Set 和 ImmutableSet 两者都支持 set 与 set 之间的比较。两个 sets 在也只有在这种情况下是相等的：每一个 set 中的元素都是另一个中的元素（二者互为subset）。一个 set 比另一个 set 小，只有在第一个 set 是第二个 set 的 subset 时（是一个 subset，但是并不相等）。一个 set 比另一个 set 打，只有在第一个 set 是第二个 set 的 superset 时（是一个 superset，但是并不相等）。

子 set 和相等比较并不产生完整的排序功能。例如：任意两个 sets 都不相等也不互为子 set，因此以下的运算都会返回 False：a&lt;b, a==b, 或者a&gt;b。因此，sets 不提供 __cmp__ 方法。

因为 sets 只定义了部分排序功能（subset 关系），list.sort() 方法的输出对于 sets 的列表没有定义。


运算符
   运算结果

hash(s)
   返回 s 的 hash 值


下面这个表列出了对于 Set 可用二对于 ImmutableSet 不可用的运算：

运算符（voperator）
等价于
运算结果

s.update(t)
s |= t
返回增加了 set “t”中元素后的 set “s”

s.intersection_update(t)
s &amp;= t
返回只保留含有 set “t”中元素的 set “s”

s.difference_update(t)
s -= t
返回删除了 set “t”中含有的元素后的 set “s”

s.symmetric_difference_update(t)
s ^= t
返回含有 set “t”或者 set “s”中有而不是两者都有的元素的 set “s”

s.add(x)

向 set “s”中增加元素 x

s.remove(x)

从 set “s”中删除元素 x, 如果不存在则引发 KeyError

s.discard(x)

如果在 set “s”中存在元素 x, 则删除

s.pop()

删除并且返回 set “s”中的一个不确定的元素, 如果为空则引发 KeyError

s.clear()

删除 set “s”中的所有元素


请注意：非运算符版本的 update(), intersection_update(), difference_update()和symmetric_difference_update()将会接受任意 iterable 作为参数。从 2.3.1 版本做的更改：以前所有参数都必须是 sets。

还请注意：这个模块还包含一个 union_update() 方法，它是 update() 方法的一个别名。包含这个方法是为了向后兼容。程序员们应该多使用 update() 方法，因为这个方法也被内置的 set() 和 frozenset() 类型支持。</code></pre><p>【题目:050】| 说说decorator的用法和它的应用场景，如果可以的话，写一个decorator</p>
<pre><code>所谓装饰器就是把函数包装一下，为函数添加一些附加功能，装饰器就是一个函数，参数为被包装的函数，返回包装后的函数：

def d(fp):
    def _d(*arg, **karg):
        print &quot;do sth before fp..&quot;
        r= fp(*arg, **karg)
        print &quot;do sth after fp..&quot;
        return r
    return _d

@d
def f():
    print &quot;call f&quot;
#上面使用@d来表示装饰器和下面是一个意思
#f = d(f)


f()#调用f</code></pre><p>【题目:051】| 写一个类，并让它尽可能多的支持操作符</p>
<pre><code>class Array:
    __list = []

    def __init__(self):
        print &quot;constructor&quot;

    def __del__(self):
        print &quot;destructor&quot;

    def __str__(self):
        return &quot;this self-defined array class&quot;

    def __getitem__(self, key):
        return self.__list[key]

    def __len__(self):
        return len(self.__list)

    def Add(self, value):
        self.__list.append(value)

    def Remove(self, index):
        del self.__list[index]

    def DisplayItems(self):
        print &quot;show all items----&quot;
        for item in self.__list:
            print item

arr = Array()   #constructor
print arr    #this self-defined array class
print len(arr)   #0
arr.Add(1)
arr.Add(2)
arr.Add(3)
print len(arr)   #3
print arr[0]   #1
arr.DisplayItems()
#show all items----
#1
#2
#3
arr.Remove(1)
arr.DisplayItems()
#show all items----
#1
#3
#destructor</code></pre><p>【题目:052】| 说一说你见过比较cool的python实现</p>
<pre><code>cool的概念，角度不同，看法可能也就不同，个人觉得更Pythonic的代码就是最酷的代码。</code></pre><p>【题目:053】| Python如何实现单例模式</p>
<pre><code>#-*- encoding=utf-8 -*-
print &apos;----------------------方法1--------------------------&apos;
#方法1,实现__new__方法
#并在将一个类的实例绑定到类变量_instance上,
#如果cls._instance为None说明该类还没有实例化过,实例化该类,并返回
#如果cls._instance不为None,直接返回cls._instance
class Singleton(object):
    def __new__(cls, *args, **kw):
        if not hasattr(cls, &apos;_instance&apos;):
            orig = super(Singleton, cls)
            cls._instance = orig.__new__(cls, *args, **kw)
        return cls._instance

class MyClass(Singleton):
    a = 1

one = MyClass()
two = MyClass()

two.a = 3
print one.a
#3
#one和two完全相同,可以用id(), ==, is检测
print id(one)
#29097904
print id(two)
#29097904
print one == two
#True
print one is two
#True

print &apos;----------------------方法2--------------------------&apos;
#方法2,共享属性;所谓单例就是所有引用(实例、对象)拥有相同的状态(属性)和行为(方法)
#同一个类的所有实例天然拥有相同的行为(方法),
#只需要保证同一个类的所有实例具有相同的状态(属性)即可
#所有实例共享属性的最简单最直接的方法就是__dict__属性指向(引用)同一个字典(dict)
#可参看:http://code.activestate.com/recipes/66531/
class Borg(object):
    _state = {}
    def __new__(cls, *args, **kw):
        ob = super(Borg, cls).__new__(cls, *args, **kw)
        ob.__dict__ = cls._state
        return ob

class MyClass2(Borg):
    a = 1

one = MyClass2()
two = MyClass2()

#one和two是两个不同的对象,id, ==, is对比结果可看出
two.a = 3
print one.a
#3
print id(one)
#28873680
print id(two)
#28873712
print one == two
#False
print one is two
#False
#但是one和two具有相同的（同一个__dict__属性）,见:
print id(one.__dict__)
#30104000
print id(two.__dict__)
#30104000

print &apos;----------------------方法3--------------------------&apos;
#方法3:本质上是方法1的升级（或者说高级）版
#使用__metaclass__（元类）的高级python用法
class Singleton2(type):
    def __init__(cls, name, bases, dict):
        super(Singleton2, cls).__init__(name, bases, dict)
        cls._instance = None
    def __call__(cls, *args, **kw):
        if cls._instance is None:
            cls._instance = super(Singleton2, cls).__call__(*args, **kw)
        return cls._instance

class MyClass3(object):
    __metaclass__ = Singleton2

one = MyClass3()
two = MyClass3()

two.a = 3
print one.a
#3
print id(one)
#31495472
print id(two)
#31495472
print one == two
#True
print one is two
#True

print &apos;----------------------方法4--------------------------&apos;
#方法4:也是方法1的升级（高级）版本,
#使用装饰器(decorator),
#这是一种更pythonic,更elegant的方法,
#单例类本身根本不知道自己是单例的,因为他本身(自己的代码)并不是单例的
def singleton(cls, *args, **kw):
    instances = {}
    def _singleton():
        if cls not in instances:
            instances[cls] = cls(*args, **kw)
        return instances[cls]
    return _singleton

@singleton
class MyClass4(object):
    a = 1
    def __init__(self, x=0):
        self.x = x

one = MyClass4()
two = MyClass4()

two.a = 3
print one.a
#3
print id(one)
#29660784
print id(two)
#29660784
print one == two
#True
print one is two
#True
one.x = 1
print one.x
#1
print two.x
#1</code></pre><p>【题目:054】| 如何用Python来发送邮件</p>
<pre><code># 可以使用smtplib标准库。
# 以下代码可以在支持SMTP监听器的服务器上执行。

import sys, smtplib

fromaddr = raw_input(&quot;From: &quot;)
toaddrs  = raw_input(&quot;To: &quot;).split(&apos;,&apos;)
print(&quot;Enter message, end with ^D:&quot;)
msg = &apos;&apos;
while 1:
    line = sys.stdin.readline()
    if not line:
        break
msg += line

# 发送邮件部分
server = smtplib.SMTP(&apos;localhost&apos;)
server.sendmail(fromaddr, toaddrs, msg)
server.quit()</code></pre><p>【题目:055】| Python自动连接ssh的代码</p>
<pre><code>#!/usr/bin/env python

#import the need library.
import pxssh

#machine details
hostname = &apos;&apos;
username = &apos;&apos;
password = &apos;&apos;

#command we want to send
command = &apos;ls -lart&apos;

#function to connect
def connect(hostname, username, password, release):
    try:
        s = pxssh.pxssh()
        s.login(hostname, username, password, release)
        print s
        return s
    except Exception, e:
        print &quot;[-] Error Connecting: &quot; + str(e)

#func to send a command
def send_command(ssh_session, command):
    ssh_session.sendline(command)
    ssh_session.prompt()
    print ssh_session.before

#main()
if __name__ == &quot;__main__&quot;:
    session = connect(hostname, username, password)
    send_command(session, command)</code></pre><p>或者用pexpect模块</p>
<pre><code>#!/usr/bin/env python

import pexpect

def ssh_cmd(ip, passwd, cmd):
    ret = -1
    ssh = pexpect.spawn(&apos;ssh root@%s &quot;%s&quot;&apos; % (ip, cmd))
    try:
        i = ssh.expect([&apos;password:&apos;, &apos;continue connecting (yes/no)?&apos;], timeout=5)
        if i == 0 :
            ssh.sendline(passwd)
        elif i == 1:
            ssh.sendline(&apos;yes\n&apos;)
            ssh.expect(&apos;password: &apos;)
            ssh.sendline(passwd)
        ssh.sendline(cmd)
        res = ssh.read()
        print res
        ret = 0
    except pexpect.EOF:
        print &quot;EOF&quot;
        ssh.close()
        ret = -1
    except pexpect.TIMEOUT:
        print &quot;TIMEOUT&quot;
        ssh.close()
        ret = -2
    return ret

#main()
if __name__ == &quot;__main__&quot;:
    ssh_cmd(&apos;127.0.0.1&apos;, &apos;password&apos;, &apos;ls -lart&apos;)</code></pre><p>【题目:056】| 介绍一下Python Date Time方面的类</p>
<pre><code>一.time模块
time模块提供各种操作时间的函数
一般有两种表示时间的方式:
第一种: 是时间戳的方式(相对于1970.1.1 00:00:00以秒计算的偏移量),时间戳是惟一的
第二种: 以数组的形式表示即(struct_time),共有九个元素，分别表示，同一个时间戳的struct_time会因为时区不同而不同

二.datetime模块
Python提供了多个内置模块用于操作日期时间，像calendar，time，datetime。time模块。
相比于time模块，datetime模块的接口则更直观、更容易调用。
datetime模块定义了下面这几个类：
datetime.date：表示日期的类。常用的属性有year, month, day；
datetime.time：表示时间的类。常用的属性有hour, minute, second, microsecond；
datetime.datetime：表示日期时间。
datetime.timedelta：表示时间间隔，即两个时间点之间的长度。
datetime.tzinfo：与时区有关的相关信息。
datetime中，表示日期时间的是一个datetime对象
datetime中提供了strftime方法，可以将一个datetime型日期转换成字符串：</code></pre><p>【题目:057】| 写一个简单的Python socket编程</p>
<p>服务器端程序:</p>
<pre><code># FileName: server.py

import socket

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.bind((&apos;localhost&apos;, 8001))

sock.listen(5)
while True:
    conn, addr = sock.accept()
    try:
        conn.settimeout(5)
        buff = conn.recv(1024)
        if buff == &apos;1&apos;:
            conn.send(&apos;Hello, Client...&apos;)
        else:
            conn.send(&apos;Please, Go Out...&apos;)
    except socket.timeout:
        print &apos;Socket Time Out...&apos;
    finally:
        conn.close()</code></pre><p>客户端程序:</p>
<pre><code># FileName: client.py
import socket
import time

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect((&apos;localhost&apos;, 8001))
time.sleep(2)
sock.send(&apos;1&apos;)
print sock.recv(1024)
sock.close()</code></pre><p>在终端运行server.py，然后运行clien.py，会在终端打印“Hello, Client…”。</p>
<p>如果更改client.py的sock.send(‘1’)为其它值在终端会打印“Please, Go Out…”。</p>
<p>更改time.sleep(2)为大于5的数值， 服务器将会超时。</p>
<p>【题目:058】| Tkinter的ToolTip控件</p>
<pre><code>Tooltip控件是一个简单，但非常有用的控件。它能够为我们的软件提供非常漂亮的提示信息，提高软件的可用性，给用户比较好的体验。
假设现在有两个按钮，一个用来预览吊线世系图，一个用来预览行转。为了保持按钮文本的简洁，以及为按钮尺寸所限。
我们不能可能把这个按钮的主要功能通过text属性表述清楚，这个时候我们就可以用到tooltip控件了.</code></pre><p>【题目:059】| 解释一下python的and-or语法</p>
<pre><code>0 and ＊ 不需要再考虑＊是0还是1，结果是0
1 and ＊ 需要考虑＊是0还是1来决定结果。

1 or ＊ 不需要考虑后面的＊，结果为1
0 or ＊ 需要考虑后面的＊来决定结果

这个语法看起来类似于 C 语言中的 bool ? a : b 表达式。整个表达式从左到右进行演算，所以先进行 and 表达式的演算。 1 and &apos;first&apos; 演算值为 &apos;first&apos;，然后 &apos;first&apos; or &apos;second&apos; 的演算值为 &apos;first&apos;。

0 and &apos;first&apos; 演算值为 False，然后 0 or &apos;second&apos; 演算值为 &apos;second&apos;。

and-or主要是用来模仿 三目运算符 bool?a:b的，即当表达式bool为真，则取a否则取b。

and-or 技巧，bool and a or b 表达式，当 a 在布尔上下文中的值为假时，不会像 C 语言表达式 bool ? a : b 那样工作。</code></pre><p>【题目:060】| Python里关于“堆”这种数据结构的模块是哪个？“堆”有什么优点和缺点</p>
<p>这个真没有！</p>
<p>【题目:061】| 实现一个stack</p>
<pre><code>class Stack :
    def __init__( self ):
        &apos;&apos;&apos;&apos;&apos; Creates an empty stack. &apos;&apos;&apos;
        self._items = list()

    def isEmpty(self):
        &apos;&apos;&apos;&apos;&apos; Returns True if the stack is empty or False otherwise. &apos;&apos;&apos;
        return len(self) == 0

    def __len__(self):
        &apos;&apos;&apos;&apos;&apos; Returns the number of items in the stack. &apos;&apos;&apos;
        return len(self._items)

    def peek(self):
       &apos;&apos;&apos;&apos;&apos; Returns the top item on the stack without removing it. &apos;&apos;&apos;
       assert not self.isEmpty(), &quot;Cannot peek at an empty stack&quot;
       return self._items[-1]

    def pop(self):
        &apos;&apos;&apos;&apos;&apos; Removes and returns the top item on the stack. &apos;&apos;&apos;
        assert not self.isEmpty(), &quot;Cannot pop from an empty stack&quot;
        return self._items.pop()

    def push(self,item):
        &apos;&apos;&apos;&apos;&apos; Push an item onto the top of the stack. &apos;&apos;&apos;
        self._items.append( item )</code></pre><p>【题目:062】| 编写一个简单的ini文件解释器</p>
<p>db_config.ini</p>
<p>[baseconf]<br>host=127.0.0.1<br>port=3306<br>user=root<br>password=root<br>db_name=evaluting_sys<br>[concurrent]<br>processor=20</p>
<p>示例代码</p>
<pre><code>import sys,os
import ConfigParser
def test(config_file_path):
    cf = ConfigParser.ConfigParser()
    cf.read(config_file_path)

s = cf.sections()
print &apos;section:&apos;, s

o = cf.options(&quot;baseconf&quot;)
print &apos;options:&apos;, o

v = cf.items(&quot;baseconf&quot;)
print &apos;db:&apos;, v

db_host = cf.get(&quot;baseconf&quot;, &quot;host&quot;)
db_port = cf.getint(&quot;baseconf&quot;, &quot;port&quot;)
db_user = cf.get(&quot;baseconf&quot;, &quot;user&quot;)
db_pwd = cf.get(&quot;baseconf&quot;, &quot;password&quot;)

print db_host, db_port, db_user, db_pwd

cf.set(&quot;baseconf&quot;, &quot;db_pass&quot;, &quot;123456&quot;)
cf.write(open(&quot;config_file_path&quot;, &quot;w&quot;))
if __name__ == &quot;__main__&quot;:
    test(&quot;../conf/db_config.ini&quot;)</code></pre><p>【题目:063】| 现有N个纯文本格式的英文文件，实现一种检索方案，即做一个小搜索引擎</p>
<p>【题目:064】| src = “security/afafsff/?ip=123.4.56.78&amp;id=45”，请写一段代码用正则匹配出IP</p>
<pre><code>import re

src = &quot;security/afafsff/?ip=123.4.56.78&amp;id=45&quot;
m = re.search(&apos;ip=(\d{1,3}\.\d{1,3}\.\d{1,3}.\d{1,3})&apos;, src, re.S)  # re.S 改变&apos;.&apos;的行为
print m.group(1)
# 输出结果
&gt;&gt;&gt;
123.4.56.78</code></pre><p>【题目:064】| 已知仓库中有若干商品，以及相应库存，类似：</p>
<p>袜子，10</p>
<p>鞋子，20</p>
<p>拖鞋，30</p>
<p>项链，40</p>
<p>要求随机返回一种商品，要求商品被返回的概率与其库存成正比。请描述实现的思路或者直接写一个实现的函数</p>
<pre><code># -*- coding: utf-8 -*-
import random

Wa_Zhi     = [&apos;WZ&apos;] * 100
Xie_Zi     = [&apos;XZ&apos;] * 200
Tuo_Xie    = [&apos;TX&apos;] * 300
Xiang_Lian = [&apos;XL&apos;] * 400

All_Before = Wa_Zhi + Xie_Zi + Tuo_Xie + Xiang_Lian
All_After  = random.sample(All_Before, 100)
print All_After.count(&apos;WZ&apos;)
print All_After.count(&apos;XZ&apos;)
print All_After.count(&apos;TX&apos;)
print All_After.count(&apos;XL&apos;)

#输出结果，大致满足需求1: 2: 3: 4的比例
&gt;&gt;&gt;
9
19
32
40</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://vissssa.club/2019/05/15/%E9%A2%98%E7%9B%AE%E4%BA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="vissssa">
      <meta itemprop="description" content="python, flask, linux, 架构, 生活, 科技">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="vissssa">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2019/05/15/%E9%A2%98%E7%9B%AE%E4%BA%8C/" class="post-title-link" itemprop="url">题目二</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-15 00:00:00" itemprop="dateCreated datePublished" datetime="2019-05-15T00:00:00+08:00">2019-05-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2019-11-28 15:18:14" itemprop="dateModified" datetime="2019-11-28T15:18:14+08:00">2019-11-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/interview/" itemprop="url" rel="index">
                    <span itemprop="name">interview</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Python<br>数据库<br>网络<br>算法<br>其他<br>Python</p>
<p>1.python参数传递是值传递还是引用传递<br>都是引用，对于不可改变的数据类型来说，不能改变，如果修改了，事实上是新建一个对象来对待。</p>
<p>2.lambda更简单，省去命名函数名的麻烦<br>f = lambda x,y:x+y<br>print(f(1, 2))</p>
<p>3.format可以接受参数不限个数，并且位置可以不按顺序<br>print(“{1}-{0}”.format(“good”, 123)) #123-good<br>print(“{name}-{age}”.format(age=23, name=”lius”))</p>
<p>4.编码/解码<br><a href="http://www.cnblogs.com/OldJack/p/6658779.html" target="_blank" rel="noopener">http://www.cnblogs.com/OldJack/p/6658779.html</a><br>编码是指信息从一种形式或格式转换为另一种形式或格式的过程。<br>在计算机中，编码，简而言之，就是将人能够读懂的信息（通常称为明文）转换为计算机能够读懂的信息。众所周知，计算机能够读懂的是高低电平，也就是二进制位（0，1组合）。而解码，就是指将计算机的能够读懂的信息转换为人能够读懂的信息。</p>
<p>在Python2.x中，有两种字符串类型：str和unicode类型。str存bytes数据，unicode类型存unicode数据<br>在Python3.x中，也只有两种字符串类型：str和bytes类型。str类型存unicode数据，bytse类型存bytes数据，与python2.x比只是换了一下名字而已。<br>当我们在编辑文本的时候，字符在内存对应的是unicode编码的，这是因为unicode覆盖范围最广，几乎所有字符都可以显示。但是，当我们将文本等保存在磁盘时，数据是怎么变化的？<br>答案是通过某种编码方式编码的bytes字节串。比如utf-8，一种可变长编码，很好的节省了空间；当然还有历史产物的gbk编码等等。于是，在我们的文本编辑器软件都有默认的保存文件的编码方式，比如utf-8，比如gbk。当我们点击保存的时候，这些编辑软件已经”默默地”帮我们做了编码工作。<br>那当我们再打开这个文件时，软件又默默地给我们做了解码的工作，将数据再解码成unicode,然后就可以呈现明文给用户了！所以，unicode是离用户更近的数据，bytes是离计算机更近的数据。</p>
<p>5.反转<br>def reverse(text=”abc”):<br>    return text[::-1]<br>print(reverse(“12345”))</p>
<p>6.</p>
<p>7.<br>ll = [1,2,3,4,5,6,7]<br>print(ll[10:])    #输出[]</p>
<p>8.<br>keys = [“Name”, “Sex”, “Age”]<br>values = [“Jack”, “Male”, 19]<br>print(dict(zip(keys, values)))</p>
<p>9.<br>def extend(val, ll=[]):<br>    ll.append(val)<br>    return ll<br>l1 = extend(1)          #[1, 3]<br>l2 = extend(123, [])    #[123]<br>l3 = extend(3)          #[1, 3]<br>l4 = extend(456, [])    #[456]<br>print(l1, l2, l3, l4)</p>
<p>10.什么是GIL<br>Python代码的执行由Python 虚拟机(也叫解释器主循环，CPython版本)来控制，Python 在设计之初就考虑到要在解释器的主循环中，同时只有一个线程在执行，即在任意时刻，只有一个线程在解释器中运行。对Python 虚拟机的访问由全局解释器锁（GIL）来控制，正是这个锁能保证同一时刻只有一个线程在运行。<br>在多线程环境中，Python 虚拟机按以下方式执行：</p>
<ol>
<li>设置GIL</li>
<li>切换到一个线程去运行</li>
<li>运行：<br> a. 指定数量的字节码指令，或者<br> b. 线程主动让出控制（可以调用time.sleep(0)）</li>
<li>把线程设置为睡眠状态</li>
<li>解锁GIL</li>
<li>再次重复以上所有步骤<br><a href="http://m.blog.csdn.net/universe_ant/article/details/51243137" target="_blank" rel="noopener">http://m.blog.csdn.net/universe_ant/article/details/51243137</a></li>
</ol>
<p>线程全局锁(Global Interpreter Lock),即Python为了保证线程安全而采取的独立线程运行的限制,说白了就是一个核只能在同一时间运行一个线程.对于io密集型任务，python的多线程起到作用，但对于cpu密集型任务，python的多线程几乎占不到任何优势，还有可能因为争夺资源而变慢。</p>
<p>可以用多进程避免GIL的问题。</p>
<p>11.python3取消iteritems<br>在Python2.x中，items( )用于 返回一个字典的拷贝列表【Returns a copy of the list of all items (key/value pairs) in D】，占额外的内存。<br>iteritems() 用于返回本身字典列表操作后的迭代【Returns an iterator on all items(key/value pairs) in D】，不占用额外的内存。<br>Python 3.x 里面，iteritems() 和 viewitems() 这两个方法都已经废除了，而 items() 得到的结果是和 2.x 里面 viewitems() 一致的。在3.x 里 用 items()替换iteritems() ，可以用于 for 来循环遍历。</p>
<p>12.<br>try:<br>    with open(“text.txt”) as f:<br>        while True:<br>            line = f.readline()<br>            if not line:<br>                break<br>            print(line)<br>except FileNotFoundError:<br>    print(“No text.txt”)<br>#with语句使用上下文管理器对代码块进行包装，允许上下文管理器实现一些设置和清理操作<br>#with用在支持上下文管理协议的对象中，如file,thread.LockType<br>#当with语句执行时，便执行上下文表达式（context_expr）来获得一个上下文管理器，上下文管理器的职责是提供一个上下文对象，用于在with语句块中处理细节：<br>#一旦获得了上下文对象，就会调用它的<strong>enter</strong>()方法，将完成with语句块执行前的所有准备工作，如果with语句后面跟了as语句，则用<strong>enter</strong>()方法的返回值来赋值；<br>#当with语句块结束时，无论是正常结束，还是由于异常，都会调用上下文对象的<strong>exit</strong>()方法，<strong>exit</strong>()方法有3个参数，如果with语句正常结束，三个参数全部都是 None；如果发生异常，三个参数的值分别等于调用sys.exc_info()函数返回的三个值：类型（异常类）、值（异常实例）和跟踪记录（traceback），相应的跟踪记录对象。<br>#因为上下文管理器主要作用于共享资源，<strong>enter</strong>()和<strong>exit</strong>()方法干的基本是需要分配和释放资源的低层次工作，比如：数据库连接、锁分配、信号量加/减、状态管理、文件打开/关闭、异常处理等。</p>
<p>13.生成斐波那契数列<br>def fibs(x):<br>    result = [0, 1]<br>    for i in range(x-2):<br>        result.append(result[-2] + result[-1])<br>    return result<br>print(fibs(0))  #[0,1]</p>
<p>14.反序的迭代一个序列<br>x = [1,2,3,4,5]<br>for i in range(len(x)-1, -1, -1):<br>    print(x[i])</p>
<p>15.<br>L1 = [1,2,3,1,2,3,4,5]<br>L2 = []<br>[L2.append(i) for i in L1 if i not in L2]<br>print(L2)</p>
<p>16.<br>标准库线程安全的队列是哪一个，不安全是哪一个？logging是线程安全的吗？<br>线程安全即解决线程同步问题，Queue是线程安全队列，logging是线程安全的。</p>
<p>17.<br>import os<br>os.remove(filename)</p>
<p>18.得到list的交集，差集<br>l1 = [1,2,3,4,6]<br>l2 = [3,4,5,1,2]<br>l3 = [i for i in l1 if i not in l2]<br>l4 = [i for i in l1 if i in l2]<br>print(l3, l4)</p>
<p>19.<br>w = “Python is a very funny language”<br>w.find(“Python”)<br>w.replace(“Python”, “Ruby”)</p>
<p>20.<br>words = [“This”, “is”, “a”, “dog”]<br>words.sort(key=lambda x:x.lower())<br>print(words)</p>
<p>21.<br>lists = [“xyz”, “abc”, “opq”]<br>lists.sort(key=lambda x:x[1], reverse=True)<br>print(lists)</p>
<p>22.解析argv<br>import sys<br>for arg in sys.argv[1:]:<br>    print(arg)</p>
<p>23.<br>python高并发解决方案<br>twisted-&gt;tornado-&gt;gevent<br><a href="http://blog.csdn.net/screaming/article/details/51377870" target="_blank" rel="noopener">http://blog.csdn.net/screaming/article/details/51377870</a></p>
<p>24.<br>@staticmethod,@classmethod区别<br><a href="http://www.cnblogs.com/elie/p/5876210.html" target="_blank" rel="noopener">http://www.cnblogs.com/elie/p/5876210.html</a><br>25.单例<br>class Singleton(object):<br>    <strong>instance = None<br>    def __new</strong>(cls, age, name):<br>        #如果类数字能够<strong>instance没有或者没有赋值<br>        #那么就创建一个对象，并且赋值为这个对象的引用，保证下次调用这个方法时<br>        #能够知道之前已经创建过对象了，这样就保证了只有1个对象<br>        if not cls.</strong>instance:<br>            cls.<strong>instance = object.</strong>new__(cls)<br>        return cls.__instance</p>
<p>26.<br>python用递归判断字符串是否是回文<br>def isPlidromNonRecursive(inputStr):<br>    assert isinstance(inputStr, basestring)<br>    strLen = len(inputStr)<br>    currentStart = 0<br>    currentEnd = strLen - 1<br>    while currentStart &lt;= currentEnd:<br>        if inputStr[currentStart] != inputStr[currentEnd]:<br>            return False<br>        else:<br>            currentStart += 1<br>            currentEnd -= 1<br>    return True</p>
<p>def isPlidromRecursive(inputStr):<br>    assert isinstance(inputStr, basestring)<br>    if 0 &lt;= len(inputStr) &lt;= 1:<br>        return True<br>    if inputStr[0] != inputStr[-1]:<br>        return False<br>    else:<br>        return isPlidromRecursive(inputStr[1:-1])</p>
<p>def test_isPlidromNonRecursive():<br>    assert isPlidromNonRecursive(“level”)<br>    assert isPlidromNonRecursive(“noon”)<br>    assert isPlidromNonRecursive(“abcd”) == False</p>
<p>def test_isPlidromRecursive():<br>    assert isPlidromRecursive(“level”)<br>    assert isPlidromRecursive(“noon”)<br>    assert isPlidromRecursive(“abcd”) == False</p>
<p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    test_isPlidromNonRecursive()<br>    test_isPlidromRecursive()</p>
<p>27.<br>def fib(times):<br>    n = 0<br>    a,b = 0,1<br>    while n &lt; times:<br>        yield b<br>        a,b = b,a+b<br>        n+=1<br>    return    ‘done’</p>
<p>迭代器，yield，装饰器</p>
<p>yield:<br><a href="https://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do" target="_blank" rel="noopener">https://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do</a></p>
<p>迭代器：<br><a href="http://www.cnblogs.com/duwenxing/p/7397759.html" target="_blank" rel="noopener">http://www.cnblogs.com/duwenxing/p/7397759.html</a><br>迭代，顾名思义就是重复做一些事很多次（就现在循环中做的那样）。迭代器是实现了<strong>next</strong>()方法的对象（这个方法在调用时不需要任何参数），它是访问可迭代序列的一种方式，通常其从序列的第一个元素开始访问，直到所有的元素都被访问才结束。 [注意]：迭代器只能前进不能后退<br>[迭代器的优点]:<br>使用迭代器不要求事先准备好整个迭代过程中的所有元素。迭代器仅仅在迭代到某个元素时才计算该元素，而在这之前或之后元素可以不存在或者被销毁。因此迭代器适合遍历一些数量巨大甚至无限的序列。</p>
<p>生成器：<br>分类：生成器函数，生成器表达式</p>
<p><a href="http://www.cnblogs.com/rhcad/archive/2011/12/21/2295507.html" target="_blank" rel="noopener">http://www.cnblogs.com/rhcad/archive/2011/12/21/2295507.html</a><br><a href="http://www.cnblogs.com/kaituorensheng/p/3826911.html" target="_blank" rel="noopener">http://www.cnblogs.com/kaituorensheng/p/3826911.html</a><br><a href="http://python.jobbole.com/87805/" target="_blank" rel="noopener">http://python.jobbole.com/87805/</a><br><a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143178254193589df9c612d2449618ea460e7a672a366000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143178254193589df9c612d2449618ea460e7a672a366000</a><br><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-python-yield/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/opensource/os-cn-python-yield/</a><br><a href="http://blog.csdn.net/u013205877/article/details/70502508" target="_blank" rel="noopener">http://blog.csdn.net/u013205877/article/details/70502508</a><br><a href="http://python.jobbole.com/81692/" target="_blank" rel="noopener">http://python.jobbole.com/81692/</a><br><a href="http://www.cnblogs.com/gide/p/6187080.html" target="_blank" rel="noopener">http://www.cnblogs.com/gide/p/6187080.html</a><br><a href="http://www.cnblogs.com/patrick0715/p/5957387.html" target="_blank" rel="noopener">http://www.cnblogs.com/patrick0715/p/5957387.html</a><br><a href="http://blog.csdn.net/gvfdbdf/article/details/52116661" target="_blank" rel="noopener">http://blog.csdn.net/gvfdbdf/article/details/52116661</a><br><a href="http://python.jobbole.com/86632/" target="_blank" rel="noopener">http://python.jobbole.com/86632/</a></p>
<p>可以直接作用于for循环的对象统称为可迭代对象：Iterable。<br>生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值了。<br>可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。<br>生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。</p>
<p>import asyncio<br>@asyncio.coroutine<br>def countdown(number, n):<br>    while n &gt; 0:<br>        print(‘T-minus’, n, ‘({})’.format(number))<br>        yield from asyncio.sleep(1)<br>        n -= 1</p>
<p>loop = asyncio.get_event_loop()<br>tasks = [<br>    asyncio.ensure_future(countdown(“A”, 2)),<br>    asyncio.ensure_future(countdown(“B”, 3))]<br>loop.run_until_complete(asyncio.wait(tasks))<br>loop.close()</p>
<p>#############<br>import asyncio<br>async def hello():<br>        print(“Hello World”)<br>        r = await asyncio.sleep(3)<br>        print(“Again”)</p>
<p>loop = asyncio.get_event_loop()<br>tasks = [hello(), hello()]<br>loop.run_until_complete(asyncio.wait(tasks))<br>loop.close()</p>
<p>类装饰器<br>class Foo(object):<br>    def <strong>init</strong>(self, func):<br>        self.<em>func = func<br>    def <em>_call</em></em>(self):<br>        print (‘class decorator runing’)<br>        self._func()<br>        print (‘class decorator ending’)</p>
<p>@Foo<br>def bar():<br>    print (‘bar’)</p>
<p>装饰器其实也就是一个函数，一个用来包装函数的函数，返回一个修改之后的函数对象。经常被用于有切面需求的场景，较为经典的有插入日志、 性能测试、事务处理等。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量函数中与函数功能本身无关的雷同代码并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。<br>    import functools<br>    def log(tag=None):<br>        def decorator(func):<br>            @functools.wraps(func)<br>            def wrapper(<em>args, *</em>kwarg):<br>                print(tag)<br>                return func(<em>args, *</em>kwarg)<br>            return wrapper<br>        return decorator</p>
<pre><code>@log(&quot;first tag&quot;)
def run(*args, **kwarg):
    print(&quot;run&quot;)

run()
print(run.__name__)</code></pre><p>28.猴子补丁<br>#在函数活对象定义之后再去改变他们的行为<br>在运行时替换方法、属性等<br>在不修改第三方代码的情况下增加原来不支持的功能<br>在运行时为内存中的对象增加patch而不是在磁盘的源代码中增加</p>
<p>在运行时动态修改模块、类或函数，通常是添加功能或修正缺陷。猴子补丁在代码运行时（内存中）发挥作用，不会修改源码，因此只对当前运行的程序实例有效。因为猴子补丁破坏了封装，而且容易导致程序与补丁代码的实现细节紧密耦合，所以被视为临时的变通方案，不是集成代码的推荐方式。</p>
<p>29.<br>[1]*4 –&gt;[1,1,1,1,1]</p>
<p>li = [[]] * 5<br>li[0].append(19)<br>li[1].append(29)<br>li.append(39)<br>print(li)<br>[[19, 29], [19, 29], [19, 29], [19, 29], [19, 29], 39]</p>
<p>30.<br>协程的概念<br>协程是在一个线程执行过程中可以在一个子程序的预定或者随机位置中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。他本身是一种特殊的子程序或者称作函数。</p>
<p>协程，又称微线程，纤程，英文名Coroutine。协程的作用，是在执行函数A时，可以随时中断，去执行函数B，然后中断继续执行函数A(可以自由切换)。但这一过程并不是函数调用(没有调用语句)，这一整个过程看似像多线程，然而协程只有一个线程执行。</p>
<p>简单点说协程是进程和线程的升级版,进程和线程都面临着内核态和用户态的切换问题而耗费许多切换时间,而协程就是用户自己控制切换的时机,不再需要陷入系统的内核态.</p>
<p>31.<br>#如何设计deepcopy<br><a href="http://blog.csdn.net/kuaileboy1989/article/details/44151163" target="_blank" rel="noopener">http://blog.csdn.net/kuaileboy1989/article/details/44151163</a></p>
<p>#正则匹配邮箱</p>
<p>33.<br>class myClass(object):<br>    def <strong>init</strong>(self):<br>        self._some_property = “some property”<br>        self._some_another_property = “some another property”</p>
<pre><code>def normal_method(*args, **kwargs):
    print(&quot;calling normal method{0},{1}&quot;.format(args, kwargs))

@classmethod
def class_method(*args, **kwargs):
    print(&quot;calling class method{0},{1}&quot;.format(args, kwargs))

@staticmethod
def static_method(*args, **kwargs):
    print(&quot;calling static method{0},{1}&quot;.format(args, kwargs))

@property
def some_property(self, *args, **kwargs):
    print(&quot;calling some property getter{0},{1},{2}&quot;.format(self, args, kwargs))
    return self._some_property

@some_property.setter
def some_property(self, *args, **kwargs):
    print(&quot;calling some_property setter{0},{1},{2}&quot;.format(self, args, kwargs))
    self._some_property = args[0]

@property
def some_another_property(self, *args, **kwargs):
    print(&quot;calling some another property getter{0},{1},{2}&quot;.format(self, args, kwargs))
    return self._some_another_property</code></pre><p>o = myClass()<br>print(o.normal_method)#&lt;bound method myClass.normal_method of &lt;<strong>main</strong>.myClass object at 0x000000000267F160&gt;&gt;<br>o.normal_method()<br>print(o.class_method) #&lt;bound method myClass.class_method of &lt;class ‘<strong>main</strong>.myClass’&gt;&gt;<br>o.class_method()<br>print(o.static_method)#&lt;function myClass.static_method at 0x00000000026737B8&gt;<br>o.static_method()<br>o.some_property<br>o.some_another_property<br>o.some_property = [1,2,3]<br>print(o.some_property)</p>
<p>34<br>def print_content_name(path):<br>    import os<br>    for sChild in os.listdir(path):<br>        sChildPath = os.path.join(path, sChild)<br>        if os.path.isdir(sChildPath):<br>            print_content_name(sChildPath)<br>        else:<br>            print(sChildPath)</p>
<p>35.<br>from functools import reduce<br>print(reduce(lambda x,y:x+y, [1,2,3]))  #6</p>
<p>36.<br>tornado原理<br><a href="https://www.rapospectre.com/blog/understanding-tornado-ioloop" target="_blank" rel="noopener">https://www.rapospectre.com/blog/understanding-tornado-ioloop</a><br><a href="http://www.nowamagic.net/academy/detail/13321002" target="_blank" rel="noopener">http://www.nowamagic.net/academy/detail/13321002</a><br>39.<br>class P(object):<br>    n = []<br>    t = “test”<br>p1 = P()<br>p2 = P()<br>print(p1.t)<br>print(p2.t)<br>p1.t = “p1”<br>print(p1.t)   #p1<br>print(p2.t)   #test<br>p1.n.append(1)<br>p2.n.append(20)<br>print(p1.n)   #[1, 20]<br>print(p2.n)   #[1, 20]</p>
<p>40.字典推导式<br>dd = {“one”:1, “two”:2}<br>d = {k:v+1 for k,v in dd.items()}<br>print(d)</p>
<p>41.<em>args, *</em>kwargs<br>def print_everthing(<em>args):<br>    for count, thing in enumerate(args):<br>        print(“{0}-{1}”.format(count, thing))<br>def table_things(*</em>kwargs):<br>    for k, v in kwargs.items():<br>        print(“{0}-{1}”.format(k, v))<br>print_everthing(“one”, “two”, “three”)<br>table_things(first=1, second=2)</p>
<p>42.新式类和旧式类区别<br>为了统一type和class<br>在2.2之前，比如2.1版本中，类和类型是不同的，如a是ClassA的一个实例，那么a.<strong>class</strong>返回 ‘ class    <strong>main</strong>.ClassA‘ ，type(a)返回总是&lt;type ‘instance’&gt;。而引入新类后，比如ClassB是个新类，b是ClassB的实例，b.<strong>class</strong>和type(b)都是返回‘class ‘<strong>main</strong>.ClassB’ ，这样就统一了。<br>在多继承中，新式类采用广度优先搜索，而旧式类是采用深度优先搜索。</p>
<p>43.Python2和Python3区别<br>#统一了字符编码支持<br>#增加了新的语法，print，格式化字符串变量，nonlocal，yield<br>#修改了一些语法，map，filter，dict的items/keys/values由返回列表到返回迭代对象<br>#去掉了一些语法xrange，不再有经典类</p>
<p>44.<strong>new</strong>和<strong>init</strong>的区别<br><a href="http://www.jb51.net/article/52023.htm" target="_blank" rel="noopener">http://www.jb51.net/article/52023.htm</a><br>通过运行这段代码，我们可以看到，<strong>new</strong>方法的调用是发生在<strong>init</strong>之前的。其实当 你实例化一个类的时候，具体的执行逻辑是这样的：<br>1.p = Person(name, age)<br>2.首先执行使用name和age参数来执行Person类的<strong>new</strong>方法，这个<strong>new</strong>方法会 返回Person类的一个实例（通常情况下是使用 super(Persion, cls).<strong>new</strong>(cls, … …) 这样的方式）<br>3.然后利用这个实例来调用类的<strong>init</strong>方法，上一步里面<strong>new</strong>产生的实例也就是 <strong>init</strong>里面的的 self。<br>所以，<strong>init</strong> 和 <strong>new</strong> 最主要的区别在于：<br>1.<strong>init</strong> 通常用于初始化一个新实例，控制这个初始化的过程，比如添加一些属性， 做一些额外的操作，发生在类实例被创建完以后。它是实例级别的方法。<br>2.<strong>new</strong> 通常用于控制生成一个新实例的过程。它是类级别的方法。</p>
<p><strong>new</strong>是一个静态方法,而<strong>init</strong>是一个实例方法.<br><strong>new</strong>方法会返回一个创建的实例,而<strong>init</strong>什么都不返回.<br>只有在<strong>new</strong>返回一个cls的实例时后面的<strong>init</strong>才能被调用.<br>当创建一个新实例时调用<strong>new</strong>,初始化一个实例时用<strong>init</strong>.</p>
<p>45.<br>import copy<br>a = [1, 2, 3, 4, [‘a’, ‘b’]]<br>b = a<br>c = copy.copy(a)<br>d = copy.deepcopy(a)<br>a.append(5)<br>a[4].append(‘c’)<br>print(“a=”, a)     #[1,2,3,4,[‘a’, ‘b’, ‘c’], 5]<br>print(“b=”, b)       #[1,2,3,4,[‘a’, ‘b’, ‘c’], 5]<br>print(“c=”, c)       #[1,2,3,4,[‘a’, ‘b’, ‘c’]]<br>print(“d=”, d)       #[1,2,3,4,[‘a’, ‘b’]]</p>
<p>46.is和==<br>is比较id，==比较值<br>a = 1<br>b = 1<br>print(“a=1, b=1”, a is b) #True<br>x = 123456789<br>y = 123456789<br>print(“x=123456789, y=123456789”, x is y) #True<br>a = “abc”<br>b = “abc”<br>print(“a=abc, b=abc”, a is b)  #True<br>a = [1, 2]<br>b = [1, 2]<br>print(“a:[1,2], b:[1,2]”, a is b) #Flase</p>
<p>47.调度算法<br>先来先服务，最高优先权调度，时间片轮转，短作业优先</p>
<p>48.死锁<br><a href="http://blog.csdn.net/abigale1011/article/details/6450845/" target="_blank" rel="noopener">http://blog.csdn.net/abigale1011/article/details/6450845/</a><br>指多个进程循环等待它方占有的资源而无限期地僵持下去的局面。<br>产生死锁的必要条件：<br>互斥，不可抢占，占有且申请，循环等待</p>
<p>处理死锁基本方法:<br>预防死锁(摒弃除1以外的条件)<br>避免死锁(银行家算法)<br>检测死锁(资源分配图)<br>解除死锁<br>    剥夺资源<br>    撤销进程<br>49.<br>li = [lambda :x for x in range(10)]<br>print(type(li))    #list<br>print(type(li[0])) #function<br>res = li<a href="">0</a><br>print(res)  #9</p>
<p>50.<br>name = “peter”<br>def f1():<br>    print(name)<br>def f2():<br>    name = “bob”<br>    f1()<br>f2()  #peter</p>
<p>51.<br>def scope_test():<br>    def do_local():<br>        spam = “local spam”<br>    def do_nonlocal():<br>        nonlocal spam<br>        spam = “nonlocal spam” #要想修改父函数的变量，需使用nonlocal<br>    def do_global():<br>        global spam<br>        spam = “global spam”<br>    spam = “test spam”<br>    do_local()<br>    print(“After local assignment:”, spam)      #test spam<br>    do_nonlocal()<br>    print(“After nonlocal assignment:”, spam)   #nonlocal spam<br>    do_global()<br>    print(“After global assignment:”, spam)     #nonlocal spam</p>
<p>scope_test()<br>print(“In global scope:”, spam)                 #global spam</p>
<p>52.闭包   装饰器和闭包？？？<br>必须有一个内嵌函数<br>内嵌函数必须引用外部函数中的变量<br>外部函数的返回值必须是内嵌函数</p>
<p>Python中的闭包的概念， 就相当于在某个函数中又定义了一个或多个函数， 内层函数定义了具体的实现方式， 而外层返回的就是这个实现方式， 但并没有执行， 除非外层函数调用的内层的实现方法被执行了。<br>闭包函数必须含有内嵌函数，内嵌函数需要引用该嵌套函数上一级namespace中的变量，闭包函数必须返回内嵌函数。<br>def greeting_conf(prefix):<br>    def greeting(name):<br>        print(prefix, name)<br>    return greeting</p>
<p>mG = greeting_conf(“Good morning”)<br>print(“mG name is:”, mG.<strong>name</strong>)          #greeting<br>print(“id of mG is:”, id(mG))<br>mG(“Lius”)</p>
<p>aG = greeting_conf(“Good afternoon”)<br>print(“aG name is:”, aG.<strong>name</strong>)<br>print(“id of aG is:”, id(aG))<br>aG(“Lius”)</p>
<p>print(dir(aG))<br>print(aG.<strong>closure</strong>)<br>print(type(aG.<strong>closure</strong>[0]))<br>print(aG.<strong>closure</strong>[0].cell_contents)</p>
<p>mG name is: greeting<br>id of mG is: 51950456<br>Good morning Lius<br>aG name is: greeting<br>id of aG is: 51950592<br>Good afternoon Lius</p>
<p>53.<br>class A(object):<br>    def <strong>init</strong>(self):<br>        print(“Enter A”)<br>        print(“Leave A”)</p>
<p>class B(A):<br>    def <strong>init</strong>(self):<br>        print(“Enter B”)<br>        super(B, self).<strong>init</strong>()<br>        print(“Leave B”)</p>
<p>class C(A):<br>    def <strong>init</strong>(self):<br>        print(“Enter C”)<br>        super(C, self).<strong>init</strong>()<br>        print(“Leave C”)</p>
<p>class D(A):<br>    def <strong>init</strong>(self):<br>        print(“Enter D”)<br>        super(D, self).<strong>init</strong>()<br>        print(“Leave D”)</p>
<p>class E(B, C, D):<br>    def <strong>init</strong>(self):<br>        print(“Enter E”)<br>        super(E, self).<strong>init</strong>()<br>        print(“Leave E”)</p>
<p>E()<br>Enter E<br>Enter B<br>Enter C<br>Enter D<br>Enter A<br>Leave A<br>Leave D<br>Leave C<br>Leave B<br>Leave E</p>
<p>54.<br>data = [‘1’, ‘2’, ‘3’]<br>print(sum(int(i) for i in data))<br>print(reduce(lambda x,y:int(x)+int(y), data))</p>
<ol start="55">
<li>and or<br>对python而言<br>其一, 在不加括号时候, and优先级大于or<br>其二, x or y 的值只可能是x或y.  x为真就是x, x为假就是y<br>第三, x and y 的值只可能是x或y.  x为真就是y, x为假就是x</li>
</ol>
<p>56.<br>import re<br>s= “123 and 222”<br>re.sub(“\d\d\d”, “hello”, s)   #”hello and hello”</p>
<p>57.<br>import random<br>random.random()#0~1<br>random.randint(1, 20)</p>
<p>58.python拷贝文件<br>shutil模块copyfile函数<br>shutil.copyfile( src, dst) 从源src复制到dst中去。</p>
<p>58.垃圾回收：<br>引用计数<br>当一个对象的引用被创建或者复制时，对象的引用计数加1；当一个对象的引用被销毁时，对象的引用计数减1，当对象的引用计数减少为0时，就意味着对象已经再没有被使用了，可以将其内存释放掉。<br>标记清除</p>
<ol>
<li>寻找跟对象（root object）的集合作为垃圾检测动作的起点，跟对象也就是一些全局引用和函数栈中的引用，这些引用所指向的对象是不可被删除的；2. 从root object集合出发，沿着root object集合中的每一个引用，如果能够到达某个对象，则说明这个对象是可达的，那么就不会被删除，这个过程就是垃圾检测阶段；3. 当检测阶段结束以后，所有的对象就分成可达和不可达两部分，所有的可达对象都进行保留，其它的不可达对象所占用的内存将会被回收，这就是垃圾回收阶段。（底层采用的是链表将这些集合的对象连接在一起）</li>
</ol>
<p>基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。</p>
<p>分代回收<br>将系统中的所有内存块根据其存活时间划分为不同的集合，每一个集合就成为一个“代”，Python默认定义了三代对象集合，垃圾收集的频率随着“代”的存活时间的增大而减小。也就是说，活得越长的对象，就越不可能是垃圾，就应该减少对它的垃圾收集频率。那么如何来衡量这个存活时间：通常是利用几次垃圾收集动作来衡量，如果一个对象经过的垃圾收集次数越多，可以得出：该对象存活时间就越长。<br><a href="http://www.cnblogs.com/George1994/p/7349871.html" target="_blank" rel="noopener">http://www.cnblogs.com/George1994/p/7349871.html</a></p>
<p>59.map,reduce,filter</p>
<p>60.元类<br><a href="http://www.cnblogs.com/tkqasn/p/6524879.html" target="_blank" rel="noopener">http://www.cnblogs.com/tkqasn/p/6524879.html</a><br><a href="http://developer.51cto.com/art/201108/281521.htm" target="_blank" rel="noopener">http://developer.51cto.com/art/201108/281521.htm</a></p>
<p>61.线程和协程区别<br><a href="http://www.cnblogs.com/guokaixin/p/6041237.html" target="_blank" rel="noopener">http://www.cnblogs.com/guokaixin/p/6041237.html</a><br>1、进程<br>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。<br>2、线程<br>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。<br>3、协程<br>协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p>
<p>1、进程多与线程比较<br>线程是指进程内的一个执行单元,也是进程内的可调度实体。线程与进程的区别:</p>
<p>1) 地址空间:线程是进程内的一个执行单元，进程内至少有一个线程，它们共享进程的地址空间，而进程有自己独立的地址空间<br>2) 资源拥有:进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源<br>3) 线程是处理器调度的基本单位,但进程不是<br>4) 二者均可并发执行<br>5) 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制<br>2、协程多与线程进行比较</p>
<p>1) 一个线程可以多个协程，一个进程也可以单独拥有多个协程，这样python中则能使用多核CPU。<br>2) 线程进程都是同步机制，而协程则是异步<br>3) 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态</p>
<p>数据库<br>1.mysql字符集，排序规则<br>字符集，即用于定义字符在数据库中的编码的集合。 常见的字符集：utf-8 gbk 等。</p>
<p>数据库中的排序规则用来定义字符在进行排序和比较的时候的一种规则。 常见的如下：<br>（1） utf8_general_cs 和 utf8_general_ci （后缀”_cs”或者”_ci”意思是区分大小写和不区分大小写（Case Sensitive &amp; Case Insensitve））<br>（2） utf8_bin 规定每个字符串用二进制编码存储，区分大小写，可以直接存储二进制的内容</p>
<p>说明：所为排序规则，就是指字符比较时是否区分大小写，以及是按照字符编码进行比较还是直接用二进制数据比较。</p>
<p>2.varchar/char区别，大小限制，utf8字符集下varchar最多能存多少字符<br>1)<br>char的长度是不可变的，而varchar的长度是可变的，也就是说，定义一个char[10]和varchar[10],如果存进去的是‘csdn’,那么char所占的长度依然为10， 除了字符‘csdn’外，后面跟六个空格，而varchar就立马把长度变为4了，取数据的时候，char类型的要用trim()去掉多余的空格，而varchar是不需要的。<br>尽管如此，char的存取数度还是要比varchar要快得多，因为其长度固定，方便程序的存储与查找；但是char也为此付出的是空间的代价，因为其长度固定，所以难免会有多余的空格占位符占据空间，可谓是以空间换取时间效率，而varchar是以空间效率为首位的。<br>2)存储的容量不同<br>对 char 来说，最多能存放的字符个数 255，和编码无关。<br>而 varchar 呢，最多能存放 65532 个字符。VARCHAR 的最大有效长度由最大行大小和使用的字符集确定。整体最大长度是 65,532字节。</p>
<p><a href="http://blog.csdn.net/a347911/article/details/47280453" target="_blank" rel="noopener">http://blog.csdn.net/a347911/article/details/47280453</a><br><a href="http://www.cnblogs.com/webph/p/6679815.html" target="_blank" rel="noopener">http://www.cnblogs.com/webph/p/6679815.html</a></p>
<p>4.0版本以下，varchar(20)，指的是20字节，如果存放UTF8汉字时，只能存6个（每个汉字3字节）<br>5.0版本以上，varchar(20)，指的是20字符，无论存放的是数字、字母还是UTF8汉字（每个汉字3字节），都可以存放20个，最大大小是65532字节</p>
<p>3.外键有什么用，外键一定需要索引吗<br>外键：为某一表的一列，包含另一表的主键值<br>外键作用：保持数据完整性一致性。<br>需要<br>否则影响并发性，做很多无效操作<br><a href="http://blog.csdn.net/lv996074344/article/details/45866291" target="_blank" rel="noopener">http://blog.csdn.net/lv996074344/article/details/45866291</a><br><a href="http://blog.csdn.net/u012557538/article/details/44002789" target="_blank" rel="noopener">http://blog.csdn.net/u012557538/article/details/44002789</a></p>
<p>1。主键用于唯一标识表中的行数据，不能为空，一个主键值对应一行数据。另外，会自动在主键上创建索引，用于加快查询。<br>2。 外键用于两个表的联系。两个表必须具有相同类型的属性，在该属性上有相同的值。该属性应为其中一个表的主键，在另外一个表设置为外键。约束内表的数据的更新，从定义外键时可以发现 外键是和主键表联系，数据类型要统一，长度(存储大小)要统一。这样在更新数据的时候会保持一致性。<br>4.primary key和unique的区别？<br>定义了 UNIQUE 约束的字段中不能包含重复值，可以为一个或多个字段定义 UNIQUE 约束。因此，UNIQUE 即可以在字段级也可以在表级定义， 在 UNIQUED 约束的字段上可以包含空值。<br>UNIQUED 可空，可以在一个表里的一个或多个字段定义；PRIMARY KEY 不可空不可重复，在一个表里可以定义联合主键。primary key = unique +  not null</p>
<p><a href="http://blog.csdn.net/zm2714/article/details/8482625" target="_blank" rel="noopener">http://blog.csdn.net/zm2714/article/details/8482625</a></p>
<p>5.myisam和innodb区别，innodb的两阶段锁定协议是什么情况</p>
<p>两阶段锁协议，整个事务分为两个阶段，前一个阶段为加锁，后一个阶段为解锁。在加锁阶段，事务只能加锁，也可以操作数据，但不能解锁，直到事务释放第一个锁，就进入解锁阶段，此过程中事务只能解锁，也可以操作数据，不能再加锁。两阶段锁协议使得事务具有较高的并发度，因为解锁不必发生在事务结尾。它的不足是没有解决死锁的问题，因为它在加锁阶段没有顺序要求。如两个事务分别申请了A, B锁，接着又申请对方的锁，此时进入死锁状态。<br><a href="http://blog.csdn.net/endlu/article/details/51531391" target="_blank" rel="noopener">http://blog.csdn.net/endlu/article/details/51531391</a></p>
<p>MyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至你只是需要update一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。另外，MyISAM 对于 SELECT COUNT(*) 这类的计算是超快无比的。<br>InnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。他是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：事务。<br>mysql 数据库引擎: <a href="http://www.cnblogs.com/0201zcr/p/5296843.html" target="_blank" rel="noopener">http://www.cnblogs.com/0201zcr/p/5296843.html</a> MySQL存储引擎－－MyISAM与InnoDB区别: <a href="https://segmentfault.com/a/1190000008227211" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008227211</a></p>
<p>6.索引有什么用，大致原理是？<br>数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。<br>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。<br>为表设置索引要付出代价的：一是增加了数据库的存储空间，二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。<br><a href="http://blog.csdn.net/suifeng3051/article/details/52669644" target="_blank" rel="noopener">http://blog.csdn.net/suifeng3051/article/details/52669644</a><br><a href="http://chriszeng87.iteye.com/blog/1180762" target="_blank" rel="noopener">http://chriszeng87.iteye.com/blog/1180762</a><br><a href="http://blog.csdn.net/kennyrose/article/details/7532032" target="_blank" rel="noopener">http://blog.csdn.net/kennyrose/article/details/7532032</a></p>
<p>7.什么场景用redis？为什么mysql不适合<br>缓存，消息队列(list)，排行榜(set)，计数器<br><a href="http://www.scienjus.com/redis-use-case/" target="_blank" rel="noopener">http://www.scienjus.com/redis-use-case/</a><br>从效率来说：<br>Redis的数据存放在内存，所以速度快但是会受到内存空间限制。MySQL存放在硬盘，在速度上肯定没有Redis快，但是存放的数据量要多的多。<br>从功能来说：<br>Redis是一个K-V数据库，同时还支持List/Hash/Set/Sorted Set等几个简单数据结构。<br>持久化方面肯定不如MySQL可靠，内存价格。</p>
<p>8.redis事务？<br><a href="http://blog.csdn.net/hechurui/article/details/49508749" target="_blank" rel="noopener">http://blog.csdn.net/hechurui/article/details/49508749</a><br><a href="http://blog.csdn.net/why_2012_gogo/article/details/51274388" target="_blank" rel="noopener">http://blog.csdn.net/why_2012_gogo/article/details/51274388</a><br>redis的事务中，一次执行多条命令，本质是一组命令的集合，一个事务中所有的命令将被序列化，即按顺序执行而不会被其他命令插入。<br>在redis中，事务的作用就是在一个队列中一次性、顺序性、排他性的执行一系列的命令。<br>常用的关于事务的命令有：</p>
<ol>
<li><p>MULTI：使用该命令，标记一个事务块的开始，通常在执行之后会回复OK，（但不一定真的OK），这个时候用户可以输入多个操作来代替逐条操作，redis会将这些操作放入队列中。</p>
</li>
<li><p>EXEC：执行这个事务内的所有命令</p>
</li>
<li><p>DISCARD：放弃事务，即该事务内的所有命令都将取消</p>
</li>
<li><p>WATCH：监控一个或者多个key，如果这些key在提交事务（EXEC）之前被其他用户修改过，那么事务将执行失败，需要重新获取最新数据重头操作（类似于乐观锁）。</p>
</li>
<li><p>UNWATCH：取消WATCH命令对多有key的监控，所有监控锁将会被取消。</p>
</li>
<li><p>Redis服务端是个单线程的架构，不同的Client虽然看似可以同时保持连接，但发出去的命令是序列化执行的，这在通常的数据库理论下是最高级别的隔离</p>
</li>
<li><p>用MULTI/EXEC 来把多个命令组装成一次发送，达到原子性</p>
</li>
<li><p>用WATCH提供的乐观锁功能，在你EXEC的那一刻，如果被WATCH的键发生过改动，则MULTI到EXEC之间的指令全部不执行，不需要rollback</p>
</li>
<li><p>其他回答中提到的DISCARD指令只是用来撤销EXEC之前被暂存的指令，并不是回滚</p>
</li>
</ol>
<p>9.redis内存满了怎么办<br>1.加内存<br>2.清理数据，设置 lru 过期机制 Least Recently Used<br>3.搭集群 或者 再弄个实例用twemproxy均衡数据<br><a href="http://blog.jobbole.com/107084/" target="_blank" rel="noopener">http://blog.jobbole.com/107084/</a></p>
<p>10.mysql锁种类，死锁如何产生的<br>MySQL有三种锁的级别：页级、表级、行级。<br>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。<br>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。<br>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。<br>所谓死锁<DeadLock>: 是指两个或两个以上的进程在执行过程中,<br>因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去.<br>此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等待的进程称为死锁进程.<br>表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB.</p>
<p>死锁的关键在于：两个(或以上)的Session加锁的顺序不一致。<br>那么对应的解决死锁问题的关键就是：让不同的session加锁有次序<br><a href="http://blog.csdn.net/csdn265/article/details/51780852" target="_blank" rel="noopener">http://blog.csdn.net/csdn265/article/details/51780852</a><br><a href="http://www.cnblogs.com/zejin2008/p/5262751.html" target="_blank" rel="noopener">http://www.cnblogs.com/zejin2008/p/5262751.html</a></p>
<p>11.join种类<br><a href="http://www.cnblogs.com/dynas/p/6908707.html" target="_blank" rel="noopener">http://www.cnblogs.com/dynas/p/6908707.html</a><br>12.索引类型，BTree和hash索引区别<br><a href="http://www.cnblogs.com/hanybblog/p/6485419.html" target="_blank" rel="noopener">http://www.cnblogs.com/hanybblog/p/6485419.html</a><br>Hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位，不像B-Tree索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree索引。<br>（1）Hash索引仅仅能满足”=”,”IN”和”&lt;=&gt;”查询，不能使用范围查询。<br>（2）Hash 索引无法被用来避免数据的排序操作。<br>（3）Hash索引不能利用部分索引键查询。</p>
<p>13.Redis面试题及分布式集群<br><a href="http://blog.csdn.net/jinfeiteng2008/article/details/53711752" target="_blank" rel="noopener">http://blog.csdn.net/jinfeiteng2008/article/details/53711752</a><br><a href="http://blog.csdn.net/yajlv/article/details/73467865" target="_blank" rel="noopener">http://blog.csdn.net/yajlv/article/details/73467865</a></p>
<p>14.事务<br>数据库事务(Database Transaction) ，是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。<br><a href="http://www.hollischuang.com/archives/898" target="_blank" rel="noopener">http://www.hollischuang.com/archives/898</a></p>
<p>15.悲观锁乐观锁<br>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作<br>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。<br>乐观锁与悲观锁的具体区别: <a href="http://www.cnblogs.com/Bob-FD/p/3352216.html" target="_blank" rel="noopener">http://www.cnblogs.com/Bob-FD/p/3352216.html</a></p>
<p>redis和memcache比较</p>
<p>网络<br>1.<br>poll,epoll，select区别，边缘触发，水平触发区别<br><a href="http://www.cnblogs.com/Anker/p/3265058.html" target="_blank" rel="noopener">http://www.cnblogs.com/Anker/p/3265058.html</a><br>select，poll，epoll都是IO多路复用的机制。<br>I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。<br>水平触发(level-triggered，也被称为条件触发)LT: 只要满足条件，就触发一个事件(只要有数据没有被获取，内核就不断通知你)。select属于条件触发。<br>边缘触发(edge-triggered)ET: 每当状态变化时，触发一个事件。</p>
<p>2.tcp粘包，如何处理<br><a href="http://www.cnblogs.com/kex1n/p/6502002.html" target="_blank" rel="noopener">http://www.cnblogs.com/kex1n/p/6502002.html</a><br><a href="http://blog.csdn.net/zhangxinrun/article/details/6721495" target="_blank" rel="noopener">http://blog.csdn.net/zhangxinrun/article/details/6721495</a><br>TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。<br>粘包与拆包是由于TCP协议是字节流协议，没有记录边界所导致的。 所以如何确定一个完整的业务包就由应用层来处理了。 （这就是分包机制，本质上就是要在应用层维护消息与消息的边界。） 分包机制一般有两个通用的解决方法： 1,特殊字符控制，例如FTP协议。 2,在包头首都添加数据包的长度，例如HTTP协议。</p>
<p>3.time_wait是什么情况，出现过多的close_wait原因<br><a href="http://blog.csdn.net/yusiguyuan/article/details/21445883" target="_blank" rel="noopener">http://blog.csdn.net/yusiguyuan/article/details/21445883</a><br><a href="http://www.cnblogs.com/Jessy/p/3535612.html" target="_blank" rel="noopener">http://www.cnblogs.com/Jessy/p/3535612.html</a><br>CLOSE_WAIT<br>发起TCP连接关闭的一方称为client，被动关闭的一方称为server。被动关闭的server收到FIN后，<br>但未发出ACK的TCP状态是CLOSE_WAIT。出现这种状况一般都是由于server端代码的问题，<br>如果你的服务器上出现大量CLOSE_WAIT，应该要考虑检查代码。<br>TIME_WAIT<br>根据TCP协议定义的3次握手断开连接规定,发起socket主动关闭的一方 socket将进入TIME_WAIT状态。<br>TIME_WAIT状态将持续2个MSL(Max Segment Lifetime),在Windows下默认为4分钟，即240秒。<br>TIME_WAIT状态下的socket不能被回收使用. 具体现象是对于一个处理大量短连接的服务器,<br>如果是由服务器主动关闭客户端的连接，将导致服务器端存在大量的处于TIME_WAIT状态的socket，<br>甚至比处于Established状态下的socket多的多,严重影响服务器的处理能力，甚至耗尽可用的socket，停止服务。</p>
<p>4.https过程<br>http 运行在TCP 之上，数据明文传输。HTTPS 运行在SSL/TLS之上，SSL/TLS运行在TCP之上，是加密协议，因此HTTPS传输的已经是加密的数据，加密采用对称加密。但对称加密的密钥用服务器方的证书进行了非对称加密。SSL/TLS中使用了非对称加密，对称加密以及HASH算法。<br><a href="http://www.cnblogs.com/binyue/p/4500578.html" target="_blank" rel="noopener">http://www.cnblogs.com/binyue/p/4500578.html</a><br>HTTPS一般使用的加密与HASH算法如下：<br>非对称加密算法：RSA，DSA/DSS<br>对称加密算法：AES，RC4，3DES<br>HASH算法：MD5，SHA1，SHA256</p>
<p>5.TCP UDP的区别 滑动窗口</p>
<p>滑动窗口：滑动窗口是TCP传输时的一个缓冲区机制，用来解决传输控制和流量控制的问题，TCP在发送端和接收端都有一个滑动窗口，当接收端成功接收了某段数据并移动了接收窗口的时候，发送端的窗口也会随之移动到缓冲区后面的数据段中。</p>
<p>6.socket长连接<br>长连接与短连接的概念：前者是整个通讯过程，客户端和服务端只用一个Socket对象，长期保持Socket的连接；后者是每次请求，都新建一个Socket,处理完一个请求就直接关闭掉Socket。所以，其实区分长短连接就是：整个客户和服务端的通讯过程是利用一个Socket还是多个Socket进行的。<br>连接→数据传输→保持连接(心跳)→数据传输→保持连接(心跳)→……→关闭连接；<br>这就要求长连接在没有数据通信时，定时发送数据包(心跳)，以维持连接状态，短连接在没有数据传输时直接关闭就行了。<br><a href="http://blog.csdn.net/zdwzzu2006/article/details/7723738" target="_blank" rel="noopener">http://blog.csdn.net/zdwzzu2006/article/details/7723738</a></p>
<p>对称加密与非对称加密区别？<br>对称加密是指加密和解密使用的密钥是同一个密钥，或者可以相互推算。<br>对称加密的优点是算法简单，加解密效率高，系统开销小，适合对大数据量加密。<br>缺点是解密加密使用同一个密钥，需要考虑远程通信的情况下如何安全的交换密钥，如果密钥丢失，所谓的加密解密就失效了。<br>非对称加密和解密使用的密钥不是同一密钥，其中一个对外界公开，被称为公钥，另一个只有所有者知道称作私钥。<br>用公钥加密的信息必须用私钥才能解开，反之，用私钥加密的信息只有用公钥才能解开。</p>
<p>7.get post区别<br><a href="http://www.cnblogs.com/nankezhishi/archive/2012/06/09/getandpost.html" target="_blank" rel="noopener">http://www.cnblogs.com/nankezhishi/archive/2012/06/09/getandpost.html</a></p>
<ol>
<li>GET使用URL或Cookie传参。而POST将数据放在BODY中。</li>
<li>GET的URL会有长度上的限制，则POST的数据则可以非常大。</li>
<li>POST比GET安全，因为数据在地址栏上不可见。<br><a href="http://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html" target="_blank" rel="noopener">http://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html</a></li>
</ol>
<p>8.session，cookie区别，为什么说session是安全的<br><a href="http://blog.csdn.net/rongwenbin/article/details/51784620" target="_blank" rel="noopener">http://blog.csdn.net/rongwenbin/article/details/51784620</a><br>9.uwsgi，nginx作用</p>
<p>WSGI 是服务器程序与应用程序的一个约定，它规定了双方各自需要实现什么接口，提供什么功能，以便二者能够配合使用。<br><a href="http://www.cnblogs.com/Xjng/p/aa4dd23918359c6414d54e4b972e9081.html" target="_blank" rel="noopener">http://www.cnblogs.com/Xjng/p/aa4dd23918359c6414d54e4b972e9081.html</a><br><a href="http://blog.csdn.net/u014761344/article/details/40146597" target="_blank" rel="noopener">http://blog.csdn.net/u014761344/article/details/40146597</a><br><a href="http://www.cnblogs.com/gdkl/p/6807667.html" target="_blank" rel="noopener">http://www.cnblogs.com/gdkl/p/6807667.html</a><br><a href="http://www.cnblogs.com/luchuangao/p/Gunicorn.html" target="_blank" rel="noopener">http://www.cnblogs.com/luchuangao/p/Gunicorn.html</a></p>
<p>gunicorn<br>gunicorn 会启动一组 worker进程，所有worker进程公用一组listener，在每个worker中为每个listener建立一个wsgi server。每当有HTTP链接到来时，wsgi server创建一个协程来处理该链接，协程处理该链接的时候，先初始化WSGI环境，然后调用用户提供的app对象去处理HTTP请求。</p>
<p>10.浏览器一个请求从发送到返回经历了什么<br><a href="http://www.cnblogs.com/xiexj/p/6439775.html" target="_blank" rel="noopener">http://www.cnblogs.com/xiexj/p/6439775.html</a></p>
<p>11.短连接如何设计<br><a href="https://segmentfault.com/a/1190000011171643" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011171643</a></p>
<p>12.微信红包设计<br><a href="http://www.open-open.com/lib/view/open1430729729960.html" target="_blank" rel="noopener">http://www.open-open.com/lib/view/open1430729729960.html</a><br>设计一个类似QQ的工具</p>
<p>13.下图是最基本的web服务器的结构图。<br><a href="https://github.com/liukelin/canal_mysql_nosql_sync" target="_blank" rel="noopener">https://github.com/liukelin/canal_mysql_nosql_sync</a></p>
<p>14.<br>15.tcp面试<br><a href="http://blog.csdn.net/u012658346/article/details/51192944" target="_blank" rel="noopener">http://blog.csdn.net/u012658346/article/details/51192944</a><br><a href="http://www.cnblogs.com/freebrid/p/4640748.html" target="_blank" rel="noopener">http://www.cnblogs.com/freebrid/p/4640748.html</a><br><a href="http://blog.csdn.net/hyqwmxsh/article/details/52437499" target="_blank" rel="noopener">http://blog.csdn.net/hyqwmxsh/article/details/52437499</a></p>
<p>16.</p>
<p>CSRF:<br><a href="http://www.cnblogs.com/shytong/p/5308667.html" target="_blank" rel="noopener">http://www.cnblogs.com/shytong/p/5308667.html</a><br>其原理是攻击者构造网站后台某个功能接口的请求地址，诱导用户去点击或者用特殊方法让该请求地址自动加载。用户在登录状态下这个请求被服务端接收后会被误以为是用户合法的操作。对于 GET 形式的接口地址可轻易被攻击，对于 POST 形式的接口地址也不是百分百安全，攻击者可诱导用户进入带 Form 表单可用POST方式提交参数的页面。</p>
<p>CSRF工具的防御手段</p>
<ol>
<li>尽量使用POST，限制GET<br>GET接口太容易被拿来做CSRF攻击，看第一个示例就知道，只要构造一个img标签，而img标签又是不能过滤的数据。接口最好限制为POST使用，GET则无效，降低攻击风险。<br>当然POST并不是万无一失，攻击者只要构造一个form就可以，但需要在第三方页面做，这样就增加暴露的可能性。</li>
<li>浏览器Cookie策略<br>IE6、7、8、Safari会默认拦截第三方本地Cookie（Third-party Cookie）的发送。但是Firefox2、3、Opera、Chrome、Android等不会拦截，所以通过浏览器Cookie策略来防御CSRF攻击不靠谱，只能说是降低了风险。<br>PS：Cookie分为两种，Session Cookie（在浏览器关闭后，就会失效，保存到内存里），Third-party Cookie（即只有到了Exprie时间后才会失效的Cookie，这种Cookie会保存到本地）。<br>PS：另外如果网站返回HTTP头包含P3P Header，那么将允许浏览器发送第三方Cookie。</li>
<li>加验证码<br>验证码，强制用户必须与应用进行交互，才能完成最终请求。在通常情况下，验证码能很好遏制CSRF攻击。但是出于用户体验考虑，网站不能给所有的操作都加上验证码。因此验证码只能作为一种辅助手段，不能作为主要解决方案。</li>
<li>Referer Check<br>Referer Check在Web最常见的应用就是“防止图片盗链”。同理，Referer Check也可以被用于检查请求是否来自合法的“源”（Referer值是否是指定页面，或者网站的域），如果都不是，那么就极可能是CSRF攻击。<br>但是因为服务器并不是什么时候都能取到Referer，所以也无法作为CSRF防御的主要手段。但是用Referer Check来监控CSRF攻击的发生，倒是一种可行的方法。</li>
<li>Anti CSRF Token<br>现在业界对CSRF的防御，一致的做法是使用一个Token（Anti CSRF Token）。<br>例子：</li>
<li>用户访问某个表单页面。</li>
<li>服务端生成一个Token，放在用户的Session中，或者浏览器的Cookie中。</li>
<li>在页面表单附带上Token参数。</li>
<li>用户提交请求后， 服务端验证表单中                                                                                                                                                                                                                                                                                                                                                                                                                                                                Token是否与用户Session（或Cookies）中的Token一致，一致为合法请求，不是则非法请求。<br>这个Token的值必须是随机的，不可预测的。由于Token的存在，攻击者无法再构造一个带有合法Token的请求实施CSRF攻击。另外使用Token时应注意Token的保密性，尽量把敏感操作由GET改为POST，以form或AJAX形式提交，避免Token泄露。<br>注意：<br>CSRF的Token仅仅用于对抗CSRF攻击。当网站同时存在XSS漏洞时候，那这个方案也是空谈。所以XSS带来的问题，应该使用XSS的防御方案予以解决。</li>
</ol>
<p>AJAX,Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）, 是与在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术。</p>
<p>中间人攻击（Man-in-the-middle attack，通常缩写为MITM）是指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。</p>
<p>Socket=Ip address+ TCP/UDP + port</p>
<p>HTTP 1.1与HTTP 1.0的比较<br><a href="http://blog.csdn.net/elifefly/article/details/3964766" target="_blank" rel="noopener">http://blog.csdn.net/elifefly/article/details/3964766</a></p>
<p>理解RESTful架构<br><a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/09/restful.html</a></p>
<p>浏览器缓存机制<br><a href="http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html" target="_blank" rel="noopener">http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html</a></p>
<p>算法</p>
<p>leetcode:<a href="https://github.com/bluedazzle/leetcode_python" target="_blank" rel="noopener">https://github.com/bluedazzle/leetcode_python</a></p>
<p>其他<br>工作流<br>session共享，redis怎么存储session，session失效机制<br>session过期时间，过长怎么样<br>redis复制过程，redis插槽分配，redis主节点宕机了怎么办<br>python自省<br>tcp，udp区别，应用场景<br>io密集，cpu密集<br>多进程同时拥有同一个描述符的情况：惊群<br>面试官又问多线程情况下如何保证每个线程都能平均io，我问是不是负载均衡，他说是，我就说了用线程池加round robin。他就追问怎么实现线程池，我说条件变量加blocking</p>
<p>秒杀系统设计<br>tcp如何保证可靠传输</p>
<p>HTTP请求方式<br>GET/POST 幂等、安全性，长度限制<br>HTTP状态码</p>
<p>设计一个Timer类，要求里面的类方法sleep，10s内只能被调用一次<br>两个列表s1，s2，长度不定，用什么方法可以快速判断s1,s2有没有重复的元素？比较s1,s2差异？</p>
<p>数据库是如何设计的？<br>nginx原理<br>项目缓存设计</p>
<p>觉得自己沟通能力怎么样？<br>为什么从上一家离职？<br>遇到最难解决的是什么问题？如何解决的？<br>哪件事情最有成就感？<br>缺点？</p>
<p>get,<strong>getattr</strong>,getattribute区别<br>为什么使用tornado?<br>对事件驱动编程模型的看法？<br>讲下多进程，多线程，协程<br><a href="https://www.cnblogs.com/huangguifeng/p/7632799.html" target="_blank" rel="noopener">https://www.cnblogs.com/huangguifeng/p/7632799.html</a><br>介绍一下协程的任务调度<br>实现tail命令</p>
<p>快排<br>将句子反序i am abc –&gt;abc am i<br>服务器调用accept()之前，如果服务端sleep()，客户端connect()能否成功<br>服务器调用accept()之后，如果服务器sleep()，客户端connect()能否成功<br>客户端连接成功后，如果服务器sleep()，客户端发送send()，是否可以成功<br>如果服务器主动关闭连接，那么客户端关闭连接过程<br>二叉查找树</p>
<p>改善python的91个建议<br>http协议<br>职业规划</p>
<p>生成器概念，用途，能实现什么<br>使用生成器模拟线程并发<br>gevent咋实现的</p>
<p>flask架构<br>什么是闭包<br>字节和字符区别<br>nginx负载均衡的实现<br>抢票系统<br>高并发的服务器设计<br>集群中的session同步<br>集群间做缓存，一个节点挂了怎么办<br>集群间消息队列<br>索引实现机制</p>
<p><a href="http://www.jianshu.com/p/557afbccbed0" target="_blank" rel="noopener">http://www.jianshu.com/p/557afbccbed0</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">vissssa</p>
  <div class="site-description" itemprop="description">python, flask, linux, 架构, 生活, 科技</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">vissssa</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.5.0
  </div>

        








        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  
















  

  

</body>
</html>
