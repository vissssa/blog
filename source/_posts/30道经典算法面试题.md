---
title: 30道经典算法面试题
tags:
  - 算法
  - leetcode
  - interview
categories:
  - 算法
date: 2020-3-6
description: 30道经典算法面试题，题目来自于极客时间算法面试通关40讲
---
#### 1、给定一个字符串，找出不含有重复字符的最长子串的长度。
> [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)
> 中等

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        n = len(s)
        if n < 2:
            return n

        left = right = max_len = 0
        while left <= right < n:
            if s[right] in s[left:right]:
                while left <= right and s[right] in s[left:right]:
                    left += 1
            right += 1
            max_len = max(max_len, right - left)

        return max_len

```
上述算法每次比较都会遍历为O(right-left)，优化一下成hash集合即可  
**注意** 如果是用set()来存储数据的话  不能用pop()而是要明确的删除该值，那么就需要维护一个left指针，麻烦
```python
from collections import OrderedDict

class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        n = len(s)
        if n < 2:
            return n

        max_len = cur_len = 0
        tmp = OrderedDict()
        for i in range(n):
            while s[i] in tmp:
                tmp.popitem(last=False)
                cur_len -= 1
            tmp[s[i]] = 1
            cur_len += 1
            max_len = max(max_len, cur_len)
        return max_len

```

#### 2、给定一个 32 位有符号整数，将整数中的数字进行反转。
> [7. 整数反转](https://leetcode-cn.com/problems/reverse-integer/)
> 简单
没什么东西，注意python的int不能遍历，需要转成str再翻转
```python
class Solution:
    def reverse(self, x: int) -> int:
        s = str(x)[::-1]
        res = -int(s[:-1]) if x < 0 else int(s)
        return res if -2**31 <= res <= 2**31 - 1 else 0
```
当然这是一种做法  还有一种做法就是数学方法来解
**注意**这里去绝对值是因为python//取余数的话123//10=13
```python
class Solution:
    def reverse(self, x: int) -> int:
        res, y = 0, abs(x)
        out = 1<<31 if x > 0 else (1<<31)-1
        while y != 0:
            pop = y % 10
            res = res * 10 + pop
            if res > out:
                return 0
            y //= 10
        return res if x > 0 else -res

```

#### 3、实现 atoi，将字符串转为整数。
> [8. 字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)
> 中等

这题肯定不是要你直接int()的了。。
题目很简单  但是要注意一些特例和边界问题
首先去空格  然后分析第一位是+-值或者是数字还是其它字符串
然后对每一轮结果做一个判断边界
比较麻烦的就是边界的处理  对应正负值的不同比较和返回
```python
class Solution:
    def myAtoi(self, str: str) -> int:
        s = str.lstrip()
        if not s:
            return 0
        flag = True
        if s[0] == '-':
            flag = False
            s = s[1:]
        elif s[0] == '+':
            s = s[1:]
        res = i = 0
        bo = (1 << 31) - 1 if flag else 1 << 31
        while i < len(s) and s[i].isdigit():
            res = res * 10 + int(s[i])
            if res > bo:
                return (1 << 31) - 1 if flag else -1 << 31
            i += 1
        return res if flag else -res

```

#### 4、给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在 坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的 两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
> [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)
> 中等

![](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg)

双指针 双向往中间移动  
至于某些没有涉及到的面积比如这题的2-7
面积的高度依赖于更小的那个，那么肯定是小于长度比它长的1-7
所以中间的都不用去计算
```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        if not height:
            return 0
        n = len(height)
        max_len, left, right = 0, 0, n - 1
        while left < right:
            max_len = max(max_len, min(height[left], height[right]) * (right - left))
            if height[left] > height[right]:
                right -= 1
            else:
                left += 1
        return max_len

```

#### 5、编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 ""。
> [14. 最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix/)
> 简单
res = compare(compare(compare(s1,s2),s3),s4)
自然想到了使用reduce来解
进阶版可以考虑到搜索引擎的思路，维护一个树，当出现不同时，新增一个分支，最后返回一个最长公共前缀
```python
from functools import reduce
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if not strs:
            return ''

        def helper(x, y):
            res = []
            i = 0
            while i < min(len(x), len(y)):
                if x[i] == y[i]:
                    res.append(x[i])
                    i += 1
                else:
                    break
            return ''.join(res)

        return reduce(helper, strs)

```