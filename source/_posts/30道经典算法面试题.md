---
title: 30道经典算法面试题
tags:
  - 算法
  - leetcode
  - interview
categories:
  - 算法
date: 2020-3-6
description: 30道经典算法面试题，题目来自于极客时间算法面试通关40讲
---
#### 1. 无重复字符的最长子串
给定一个字符串，找出不含有重复字符的最长子串的长度。
> [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)
> 中等

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        n = len(s)
        if n < 2:
            return n

        left = right = max_len = 0
        while left <= right < n:
            if s[right] in s[left:right]:
                while left <= right and s[right] in s[left:right]:
                    left += 1
            right += 1
            max_len = max(max_len, right - left)

        return max_len

```
上述算法每次比较都会遍历为O(right-left)，优化一下成hash集合即可  
**注意** 如果是用set()来存储数据的话  不能用pop()而是要明确的删除该值，那么就需要维护一个left指针，麻烦
```python
from collections import OrderedDict

class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        n = len(s)
        if n < 2:
            return n

        max_len = cur_len = 0
        tmp = OrderedDict()
        for i in range(n):
            while s[i] in tmp:
                tmp.popitem(last=False)
                cur_len -= 1
            tmp[s[i]] = 1
            cur_len += 1
            max_len = max(max_len, cur_len)
        return max_len

```

#### 2. 整数反转
给定一个 32 位有符号整数，将整数中的数字进行反转。
> [7. 整数反转](https://leetcode-cn.com/problems/reverse-integer/)
> 简单
没什么东西，注意python的int不能遍历，需要转成str再翻转
```python
class Solution:
    def reverse(self, x: int) -> int:
        s = str(x)[::-1]
        res = -int(s[:-1]) if x < 0 else int(s)
        return res if -2**31 <= res <= 2**31 - 1 else 0
```
当然这是一种做法  还有一种做法就是数学方法来解
**注意**这里去绝对值是因为python//取余数的话123//10=13
```python
class Solution:
    def reverse(self, x: int) -> int:
        res, y = 0, abs(x)
        out = 1<<31 if x > 0 else (1<<31)-1
        while y != 0:
            pop = y % 10
            res = res * 10 + pop
            if res > out:
                return 0
            y //= 10
        return res if x > 0 else -res

```

#### 3. 字符串转换整数 (atoi)
实现 atoi，将字符串转为整数。
> [8. 字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)
> 中等

这题肯定不是要你直接int()的了。。
题目很简单  但是要注意一些特例和边界问题
首先去空格  然后分析第一位是+-值或者是数字还是其它字符串
然后对每一轮结果做一个判断边界
比较麻烦的就是边界的处理  对应正负值的不同比较和返回
```python
class Solution:
    def myAtoi(self, str: str) -> int:
        s = str.lstrip()
        if not s:
            return 0
        flag = True
        if s[0] == '-':
            flag = False
            s = s[1:]
        elif s[0] == '+':
            s = s[1:]
        res = i = 0
        bo = (1 << 31) - 1 if flag else 1 << 31
        while i < len(s) and s[i].isdigit():
            res = res * 10 + int(s[i])
            if res > bo:
                return (1 << 31) - 1 if flag else -1 << 31
            i += 1
        return res if flag else -res

```

#### 4. 盛最多水的容器
给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在 坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的 两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
> [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)
> 中等

![](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg)

双指针 双向往中间移动  
至于某些没有涉及到的面积比如这题的2-7
面积的高度依赖于更小的那个，那么肯定是小于长度比它长的1-7
所以中间的都不用去计算
```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        if not height:
            return 0
        n = len(height)
        max_len, left, right = 0, 0, n - 1
        while left < right:
            max_len = max(max_len, min(height[left], height[right]) * (right - left))
            if height[left] > height[right]:
                right -= 1
            else:
                left += 1
        return max_len

```

#### 5. 最长公共前缀
编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 ""。
> [14. 最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix/)
> 简单
res = compare(compare(compare(s1,s2),s3),s4)
自然想到了使用reduce来解
进阶版可以考虑到搜索引擎的思路，维护一个树，当出现不同时，新增一个分支，最后返回一个最长公共前缀
```python
from functools import reduce
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if not strs:
            return ''

        def helper(x, y):
            res = []
            i = 0
            while i < min(len(x), len(y)):
                if x[i] == y[i]:
                    res.append(x[i])
                    i += 1
                else:
                    break
            return ''.join(res)

        return reduce(helper, strs)

```

#### 6. 搜索插入位置
给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。你可以假设数组中无重复元素。
> [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)
> 简单

因为是排序数组，最简单的就是直接遍历返回即可
```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        if not nums:
            return 0
        
        n = len(nums)
        for i in range(n):
            if nums[i] >= target:
                return i
        return n
```
上述时间复杂度是O(N)
为了减少时间复杂度可以用二分法减少到O(logN)
稍微复杂点  因为要处理边界问题([1,3],2)和([1,3],3)和([1,3],4)的处理需要谨慎
```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        n = len(nums)
        left, right = 0, n - 1
        while left < right:
            mid = (right + left) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] > target:
                right = mid
            else:
                left = mid + 1
        return left if target <= nums[right] else n

```
#### 6. 跳跃游戏
给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
你的目标是使用最少的跳跃次数到达数组的最后一个位置。
> [55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)
> 中等
首先猜测这是一个动态规划
但是能做的还是先用暴力法
reversed是先从大到小跳跃，尽可能减少次数
当然了超时了
```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        n = len(nums)
        def helper(pos):
            if pos >= n - 1 or nums[pos] >= n - 1:
                return True

            for i in reversed(range(pos + 1, pos + nums[pos] + 1)):
                if helper(i):
                    return True
            return False

        return helper(0)
        
```
从底到上的动态规划
边界就是最后一个值肯定能到达自己  从这里往前推  注意去最小值 防止越界
但是这里python还是超时了(-_-||)
看来python想ac就得用最优解了

```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        n = len(nums)
        # 0 未处理  1 好坐标
        status = [0 for _ in range(n)]
        status[n - 1] = 1
        for i in reversed(range(n - 1)):
            max_move = min(n - 1, i + nums[i])
            for j in range(i + 1, max_move + 1):
                if status[j] == 1:
                    status[i] = 1
                    break

        return status[0] == 1

```
最优解其实很简单，需要稍微思考一下，从右开始只要能到达终点的就是好坐标，那么能到达好坐标的也就是好坐标，推导下来，能到达最左边的好坐标就可以标记为好坐标
```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        n = len(nums)
        left_index = n - 1
        for i in reversed(range(n - 1)):
            if i + nums[i] >= left_index:
                left_index = i
        return left_index == 0
```
还有种思路  最远能到达的位置大于终点即可
max_i >= i保证能到达i位置  防止[3,2,1,0,4]
```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        n = len(nums)
        max_i = 0
        for i, jump in enumerate(nums):
            if max_i >= i and i + jump > max_i:
                max_i = i + jump
            if max_i >= n - 1:
                return True
        return False
```