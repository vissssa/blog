<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/vissssa_favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/vissssa_favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/vissssa_favicon.ico">
  <link rel="mask-icon" href="/blog/images/vissssa_favicon.ico" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">

<link rel="stylesheet" href="//cdn.baomitu.com//css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/blog/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/blog/lib/pace/pace-theme-bounce.min.css">
  <script src="/blog/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"vissssa.gitee.io","root":"/blog/","scheme":"Gemini","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="30道经典算法面试题，题目来自于极客时间算法面试通关40讲">
<meta property="og:type" content="article">
<meta property="og:title" content="30道经典算法面试题">
<meta property="og:url" content="https://vissssa.gitee.io/blog/posts/efbabf5a/index.html">
<meta property="og:site_name" content="vissssa">
<meta property="og:description" content="30道经典算法面试题，题目来自于极客时间算法面试通关40讲">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg">
<meta property="og:image" content="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/IMG_20200316_102415.jpg">
<meta property="article:published_time" content="2020-03-05T16:00:00.000Z">
<meta property="article:modified_time" content="2020-09-21T13:09:00.347Z">
<meta property="article:author" content="vissssa">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="leetcode">
<meta property="article:tag" content="interview">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg">

<link rel="canonical" href="https://vissssa.gitee.io/blog/posts/efbabf5a/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>30道经典算法面试题 | vissssa</title>
  


  <script pjax>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?6c62fd314d902c62945f06eeb436ce1f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">vissssa</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">我的一些笔记，人生感悟、读后感、开箱评测等</h1>
      
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/blog/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/blog/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/vissssa" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="external nofollow noopener noreferrer" target="_blank"><svg width="80" height="80" viewbox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://vissssa.gitee.io/blog/posts/efbabf5a/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/hexo/%E5%A4%B4%E5%83%8F%E5%8E%8B%E7%BC%A9%E7%89%88.jpg">
      <meta itemprop="name" content="vissssa">
      <meta itemprop="description" content="python, flask, linux, 架构, 生活, 科技">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="vissssa">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          30道经典算法面试题
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-06 00:00:00" itemprop="dateCreated datePublished" datetime="2020-03-06T00:00:00+08:00">2020-03-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-21 21:09:00" itemprop="dateModified" datetime="2020-09-21T21:09:00+08:00">2020-09-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>19k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>32 分钟</span>
            </span>
            <div class="post-description">30道经典算法面试题，题目来自于极客时间算法面试通关40讲</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h4 id="1-无重复字符的最长子串"><a href="#1-无重复字符的最长子串" class="headerlink" title="1. 无重复字符的最长子串"></a>1. 无重复字符的最长子串</h4><p>给定一个字符串，找出不含有重复字符的最长子串的长度。</p>
<blockquote>
<p>原题：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="external nofollow noopener noreferrer">3. 无重复字符的最长子串</a></p>
<p>难度：中等</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line">        left = right = max_len = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right &lt; n:</span><br><span class="line">            <span class="keyword">if</span> s[right] <span class="keyword">in</span> s[left:right]:</span><br><span class="line">                <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> s[right] <span class="keyword">in</span> s[left:right]:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">            max_len = max(max_len, right - left)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>

<p>上述算法每次比较都会遍历为O(right-left)，优化一下成hash集合即可</p>
<p><strong>注意</strong> 如果是用set()来存储数据的话 不能用pop()而是要明确的删除该值，那么就需要维护一个left指针，麻烦</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line"></span><br><span class="line">        max_len = cur_len = <span class="number">0</span></span><br><span class="line">        tmp = OrderedDict()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">while</span> s[i] <span class="keyword">in</span> tmp:</span><br><span class="line">                tmp.popitem(last=<span class="literal">False</span>)</span><br><span class="line">                cur_len -= <span class="number">1</span></span><br><span class="line">            tmp[s[i]] = <span class="number">1</span></span><br><span class="line">            cur_len += <span class="number">1</span></span><br><span class="line">            max_len = max(max_len, cur_len)</span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>

<h4 id="2-整数反转"><a href="#2-整数反转" class="headerlink" title="2. 整数反转"></a>2. 整数反转</h4><p>给定一个 32 位有符号整数，将整数中的数字进行反转。</p>
<blockquote>
<p>原题：<a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="external nofollow noopener noreferrer">7. 整数反转</a></p>
<p>难度：简单</p>
</blockquote>
<p>没什么东西，注意python的int不能遍历，需要转成str再翻转</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        s = str(x)[::<span class="number">-1</span>]</span><br><span class="line">        res = -int(s[:<span class="number">-1</span>]) <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">else</span> int(s)</span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> <span class="number">-2</span>**<span class="number">31</span> &lt;= res &lt;= <span class="number">2</span>**<span class="number">31</span> - <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>当然这是一种做法 还有一种做法就是数学方法来解</p>
<p><strong>注意</strong>这里去绝对值是因为python//取余数的话123//10=13</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        res, y = <span class="number">0</span>, abs(x)</span><br><span class="line">        out = <span class="number">1</span>&lt;&lt;<span class="number">31</span> <span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">else</span> (<span class="number">1</span>&lt;&lt;<span class="number">31</span>)<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> y != <span class="number">0</span>:</span><br><span class="line">            pop = y % <span class="number">10</span></span><br><span class="line">            res = res * <span class="number">10</span> + pop</span><br><span class="line">            <span class="keyword">if</span> res &gt; out:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            y //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> x &gt; <span class="number">0</span> <span class="keyword">else</span> -res</span><br></pre></td></tr></table></figure>

<h4 id="3-字符串转换整数-atoi"><a href="#3-字符串转换整数-atoi" class="headerlink" title="3. 字符串转换整数 (atoi)"></a>3. 字符串转换整数 (atoi)</h4><p>实现 atoi，将字符串转为整数。</p>
<blockquote>
<p>原题：<a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="external nofollow noopener noreferrer">8. 字符串转换整数 (atoi)</a></p>
<p>难度：中等</p>
</blockquote>
<p>这题肯定不是要你直接int()的了。。</p>
<p>题目很难度：简单 但是要注意一些特例和边界问题</p>
<p>首先去空格 然后分析第一位是+-值或者是数字还是其它字符串</p>
<p>然后对每一轮结果做一个判断边界</p>
<p>比较麻烦的就是边界的处理 对应正负值的不同比较和返回</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span><span class="params">(self, str: str)</span> -&gt; int:</span></span><br><span class="line">        s = str.lstrip()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        flag = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">'-'</span>:</span><br><span class="line">            flag = <span class="literal">False</span></span><br><span class="line">            s = s[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">elif</span> s[<span class="number">0</span>] == <span class="string">'+'</span>:</span><br><span class="line">            s = s[<span class="number">1</span>:]</span><br><span class="line">        res = i = <span class="number">0</span></span><br><span class="line">        bo = (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) - <span class="number">1</span> <span class="keyword">if</span> flag <span class="keyword">else</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(s) <span class="keyword">and</span> s[i].isdigit():</span><br><span class="line">            res = res * <span class="number">10</span> + int(s[i])</span><br><span class="line">            <span class="keyword">if</span> res &gt; bo:</span><br><span class="line">                <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) - <span class="number">1</span> <span class="keyword">if</span> flag <span class="keyword">else</span> <span class="number">-1</span> &lt;&lt; <span class="number">31</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> flag <span class="keyword">else</span> -res</span><br></pre></td></tr></table></figure>

<h4 id="4-盛最多水的容器"><a href="#4-盛最多水的容器" class="headerlink" title="4. 盛最多水的容器"></a>4. 盛最多水的容器</h4><p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在 坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的 两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<blockquote>
<p>原题：<a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="external nofollow noopener noreferrer">11. 盛最多水的容器</a></p>
<p>难度：中等</p>
</blockquote>
<p><img data-src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt></p>
<p>双指针 双向往中间移动</p>
<p>至于某些没有涉及到的面积比如这题的2-7</p>
<p>面积的高度依赖于更小的那个，那么肯定是小于长度比它长的1-7</p>
<p>所以中间的都不用去计算</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> height:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(height)</span><br><span class="line">        max_len, left, right = <span class="number">0</span>, <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            max_len = max(max_len, min(height[left], height[right]) * (right - left))</span><br><span class="line">            <span class="keyword">if</span> height[left] &gt; height[right]:</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>

<h4 id="5-最长公共前缀"><a href="#5-最长公共前缀" class="headerlink" title="5. 最长公共前缀"></a>5. 最长公共前缀</h4><p>编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。</p>
<blockquote>
<p>原题：<a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="external nofollow noopener noreferrer">14. 最长公共前缀</a></p>
<p>难度：简单</p>
</blockquote>
<p>res = compare(compare(compare(s1,s2),s3),s4)</p>
<p>自然想到了使用reduce来解</p>
<p>进阶版可以考虑到搜索引擎的思路，维护一个树，当出现不同时，新增一个分支，最后返回一个最长公共前缀</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs: List[str])</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> strs:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(x, y)</span>:</span></span><br><span class="line">            res = []</span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; min(len(x), len(y)):</span><br><span class="line">                <span class="keyword">if</span> x[i] == y[i]:</span><br><span class="line">                    res.append(x[i])</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span>.join(res)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> reduce(helper, strs)</span><br></pre></td></tr></table></figure>

<h4 id="6-搜索插入位置"><a href="#6-搜索插入位置" class="headerlink" title="6. 搜索插入位置"></a>6. 搜索插入位置</h4><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。你可以假设数组中无重复元素。</p>
<blockquote>
<p>原题：<a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="external nofollow noopener noreferrer">35. 搜索插入位置</a></p>
<p>难度：简单</p>
</blockquote>
<p>因为是排序数组，最难度：简单的就是直接遍历返回即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt;= target:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> n</span><br></pre></td></tr></table></figure>

<p>上述时间复杂度是O(N)</p>
<p>为了减少时间复杂度可以用二分法减少到O(logN)</p>
<p>稍微复杂点 因为要处理边界问题([1,3],2)和([1,3],3)和([1,3],4)的处理需要谨慎</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        left, right = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (right + left) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &gt; target:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left <span class="keyword">if</span> target &lt;= nums[right] <span class="keyword">else</span> n</span><br></pre></td></tr></table></figure>

<h4 id="7-跳跃游戏"><a href="#7-跳跃游戏" class="headerlink" title="7. 跳跃游戏"></a>7. 跳跃游戏</h4><p>给定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p>
<blockquote>
<p>原题：<a href="https://leetcode-cn.com/problems/jump-game/" target="_blank" rel="external nofollow noopener noreferrer">55. 跳跃游戏</a></p>
<p>难度：中等</p>
</blockquote>
<p>首先猜测这是一个动态规划</p>
<p>但是能做的还是先用暴力法</p>
<p>reversed是先从大到小跳跃，尽可能减少次数</p>
<p>当然了超时了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(pos)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> pos &gt;= n - <span class="number">1</span> <span class="keyword">or</span> nums[pos] &gt;= n - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(pos + <span class="number">1</span>, pos + nums[pos] + <span class="number">1</span>)):</span><br><span class="line">                <span class="keyword">if</span> helper(i):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> helper(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>从底到上的动态规划</p>
<p>边界就是最后一个值肯定能到达自己 从这里往前推 注意去最小值 防止越界</p>
<p>但是这里python还是超时了(-_-||)</p>
<p>看来python想ac就得用最优解了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="comment"># 0 未处理  1 好坐标</span></span><br><span class="line">        status = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        status[n - <span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(n - <span class="number">1</span>)):</span><br><span class="line">            max_move = min(n - <span class="number">1</span>, i + nums[i])</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, max_move + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> status[j] == <span class="number">1</span>:</span><br><span class="line">                    status[i] = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> status[<span class="number">0</span>] == <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>最优解其实很难度：简单，需要稍微思考一下，从右开始只要能到达终点的就是好坐标，那么能到达好坐标的也就是好坐标，推导下来，能到达最左边的好坐标就可以标记为好坐标</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        left_index = n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> reversed(range(n - <span class="number">1</span>)):</span><br><span class="line">            <span class="keyword">if</span> i + nums[i] &gt;= left_index:</span><br><span class="line">                left_index = i</span><br><span class="line">        <span class="keyword">return</span> left_index == <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>还有种思路 最远能到达的位置大于终点即可</p>
<p>max_i &gt;= i保证能到达i位置 防止[3,2,1,0,4]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        max_i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, jump <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> max_i &gt;= i <span class="keyword">and</span> i + jump &gt; max_i:</span><br><span class="line">                max_i = i + jump</span><br><span class="line">            <span class="keyword">if</span> max_i &gt;= n - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h4 id="8-旋转图像"><a href="#8-旋转图像" class="headerlink" title="8. 旋转图像"></a>8. 旋转图像</h4><p>给定一个 n × n 的二维矩阵表示一个图像。</p>
<p>将图像顺时针旋转 90 度。</p>
<p>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p>
<blockquote>
<p>原题：<a href="https://leetcode-cn.com/problems/rotate-image/" target="_blank" rel="external nofollow noopener noreferrer">48. 旋转图像</a></p>
<p>难度：中等</p>
</blockquote>
<p>在纸上多画画 先对中翻转再左下右上斜对角</p>
<p>然后用代码实现即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(matrix)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            left, right = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                matrix[i][left], matrix[i][right] = matrix[i][right], matrix[i][left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> i + j &lt; n - <span class="number">1</span>:</span><br><span class="line">                    matrix[i][j], matrix[n - <span class="number">1</span> - j][n - <span class="number">1</span> - i] =  matrix[n - <span class="number">1</span> - j][n - <span class="number">1</span> - i], matrix[i][j]</span><br></pre></td></tr></table></figure>

<h4 id="9-二叉树的层次遍历"><a href="#9-二叉树的层次遍历" class="headerlink" title="9. 二叉树的层次遍历"></a>9. 二叉树的层次遍历</h4><p>给定一个二叉树，返回其按层次遍历的节点值。 (即逐层地，从左到右访 问所有节点)。</p>
<blockquote>
<p>原题：<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="external nofollow noopener noreferrer">102. 二叉树的层次遍历</a></p>
<p>难度：中等</p>
</blockquote>
<p>深度优先搜索DFS depth first search</p>
<p>用层数来给各级别节点空列表append</p>
<p>先想到了递归 写出来再尝试迭代减少栈的空间占用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(node, level)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(res) == level:</span><br><span class="line">                res.append([])</span><br><span class="line">            res[level].append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                helper(node.left, level + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                helper(node.right, level + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        helper(root, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>这道题更直观的是用广度优先搜索BFS breadth first search</p>
<p>使用一个双向队列(deque，这里我用的是列表，还可以from collections import deque)</p>
<p>把每一层的放到队列中再全部出队列进行append处理</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        level = <span class="number">0</span></span><br><span class="line">        deque = [root]</span><br><span class="line">        <span class="keyword">while</span> deque:</span><br><span class="line">            res.append([])</span><br><span class="line">            n = len(deque)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                node = deque.pop(<span class="number">0</span>)</span><br><span class="line">                res[level].append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    deque.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    deque.append(node.right)</span><br><span class="line">            level += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h4 id="10-只出现一次的数字"><a href="#10-只出现一次的数字" class="headerlink" title="10. 只出现一次的数字"></a>10. 只出现一次的数字</h4><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均 出现两次。找出那个只出现了一次的元素。</p>
<p>说明:</p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗?</p>
<blockquote>
<p>原题：<a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="external nofollow noopener noreferrer">136. 只出现一次的数字</a></p>
<p>难度：简单</p>
</blockquote>
<p>这道题属于难度：简单我是没想到的 因为限定死了不使用额外空间</p>
<p>所以只能使用异或运算</p>
<p>还有道题类似，不过那个题限定整数有个范围，可以使用每个数乘以等于-1 这样两次循环，最后负数的坐标就是该值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            nums[i] = nums[i - <span class="number">1</span>] ^ nums[i]</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<p>或者这么写</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y: x ^ y, nums)</span><br></pre></td></tr></table></figure>

<h4 id="11-只出现一次的数字-II"><a href="#11-只出现一次的数字-II" class="headerlink" title="11. 只出现一次的数字 II"></a>11. 只出现一次的数字 II</h4><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均 出现了三次。找出那个只出现了一次的元素。</p>
<p>说明：</p>
<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>
<blockquote>
<p>原题：<a href="https://leetcode-cn.com/problems/single-number-ii/" target="_blank" rel="external nofollow noopener noreferrer">137. 只出现一次的数字 II</a></p>
<p>难度：中等</p>
</blockquote>
<p>不懂 需要好好学习位运算 以及怎么运用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        seen_once = seen_twice = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># first appearance: </span></span><br><span class="line">            <span class="comment"># add num to seen_once </span></span><br><span class="line">            <span class="comment"># don't add to seen_twice because of presence in seen_once</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># second appearance: </span></span><br><span class="line">            <span class="comment"># remove num from seen_once </span></span><br><span class="line">            <span class="comment"># add num to seen_twice</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># third appearance: </span></span><br><span class="line">            <span class="comment"># don't add to seen_once because of presence in seen_twice</span></span><br><span class="line">            <span class="comment"># remove num from seen_twice</span></span><br><span class="line">            seen_once = ~seen_twice &amp; (seen_once ^ num)</span><br><span class="line">            seen_twice = ~seen_once &amp; (seen_twice ^ num)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> seen_once</span><br></pre></td></tr></table></figure>

<h4 id="12-排序链表"><a href="#12-排序链表" class="headerlink" title="12. 排序链表"></a>12. 排序链表</h4><p>在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</p>
<blockquote>
<p>原题：<a href="https://leetcode-cn.com/problems/sort-list/" target="_blank" rel="external nofollow noopener noreferrer">148. 排序链表</a></p>
<p>难度：中等</p>
</blockquote>
<p>O(n log n)基本就意味着归并法</p>
<p>快慢指针找中心点 递归合并</p>
<p>但是一看常数级空间复杂那就意味着不能用递归，因为会产生占空间</p>
<p>那就尝试从第一层两两排序，到第二层4 4排序直到最高层</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="comment"># 4, 3, 2, 6, 5, 7, 1</span></span><br><span class="line">        level, h, size, res = <span class="number">1</span>, head, <span class="number">0</span>, ListNode(<span class="number">0</span>)</span><br><span class="line">        res.next = head</span><br><span class="line">        <span class="keyword">while</span> h:</span><br><span class="line">            h = h.next</span><br><span class="line">            size += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        level, node = <span class="number">1</span>, head</span><br><span class="line">        <span class="keyword">while</span> level &lt; size:</span><br><span class="line">            pre, h = res, res.next</span><br><span class="line">            <span class="keyword">while</span> h:</span><br><span class="line">                h1, i = h, level</span><br><span class="line">                <span class="keyword">while</span> i <span class="keyword">and</span> h:</span><br><span class="line">                    h = h.next</span><br><span class="line">                    i -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> i:</span><br><span class="line">                    <span class="keyword">break</span>  <span class="comment"># 可能存在第一个都不满 不需要和后面进行排序了例如总长度为6：4, 3, 2, 6, 5, 7的5, 7</span></span><br><span class="line">                h2, i = h, level</span><br><span class="line">                <span class="keyword">while</span> i <span class="keyword">and</span> h:</span><br><span class="line">                    h = h.next</span><br><span class="line">                    i -= <span class="number">1</span></span><br><span class="line">                l1, l2 = level, level - i  <span class="comment"># 右部分可能不足level长度 例如 5, 7和1</span></span><br><span class="line">                <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">                    <span class="keyword">if</span> h1.val &lt; h2.val:</span><br><span class="line">                        pre.next, h1 = h1, h1.next</span><br><span class="line">                        l1 -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        pre.next, h2 = h2, h2.next</span><br><span class="line">                        l2 -= <span class="number">1</span></span><br><span class="line">                    pre = pre.next</span><br><span class="line">                pre.next = h1 <span class="keyword">if</span> l1 <span class="keyword">else</span> h2</span><br><span class="line">                <span class="keyword">while</span> l1 &gt; <span class="number">0</span> <span class="keyword">or</span> l2 &gt; <span class="number">0</span>:</span><br><span class="line">                    pre = pre.next</span><br><span class="line">                    l1 -= <span class="number">1</span></span><br><span class="line">                    l2 -= <span class="number">1</span></span><br><span class="line">                pre.next = h</span><br><span class="line"></span><br><span class="line">            level *= <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> res.next</span><br></pre></td></tr></table></figure>

<h4 id="13-寻找峰值"><a href="#13-寻找峰值" class="headerlink" title="13. 寻找峰值"></a>13. 寻找峰值</h4><p>峰值元素是指其值大于左右相邻值的元素。</p>
<p>给定一个输入数组 nums，其中 nums[i] ≠ nums[i+1]，找到峰值元素并返回其索引。</p>
<p>数组可能包含多个峰值，在这种情况下，返回任何一个峰值所在位置即可。 你可以假设 nums[-1] = nums[n] = -∞。</p>
<p>说明:</p>
<p>你的解法应该是 O(logN) 时间复杂度的。</p>
<blockquote>
<p>原题：<a href="https://leetcode-cn.com/problems/find-peak-element/" target="_blank" rel="external nofollow noopener noreferrer">162. 寻找峰值</a></p>
<p>难度：中等</p>
</blockquote>
<p>O(N)，一次遍历，需注意首尾两个值也可以是峰值，那么只需要判断当前值大于下一个值即可，如果走到这一步说明上一个值小于该值，直接返回</p>
<p>例外就是一个左下到右上的直线，此时峰值为最后一个</p>
<p>当然这种接法不符合说明</p>
<p>O(logN)明显是二分查找</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPeakElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[i + <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len(nums) - <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>值得注意的是 二分法不需要把密度和左右对比，然后左右再对比，只需要根据一个趋势来判断中间值位于下坡还是上坡</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归版</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPeakElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(left=<span class="number">0</span>, right=n - <span class="number">1</span>)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> left == right:</span><br><span class="line">                <span class="keyword">return</span> left</span><br><span class="line">            </span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; nums[mid + <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> helper(left, mid)</span><br><span class="line">            <span class="keyword">return</span> helper(mid + <span class="number">1</span>, right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> helper()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 迭代版</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPeakElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        left, right = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; nums[mid + <span class="number">1</span>]:</span><br><span class="line">                right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>

<h4 id="14-最大间距"><a href="#14-最大间距" class="headerlink" title="14. 最大间距"></a>14. 最大间距</h4><p>给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。</p>
<p>如果数组元素个数小于 2，则返回 0。</p>
<p>说明:</p>
<p>你可以假设数组中所有元素都是非负整数，且数值在 32 位有符号整数范围内。</p>
<p>请尝试在线性时间复杂度和空间复杂度的条件下解决此问题。</p>
<blockquote>
<p>原题：<a href="https://leetcode-cn.com/problems/maximum-gap/" target="_blank" rel="external nofollow noopener noreferrer">164. 最大间距</a></p>
<p>难度：困难</p>
</blockquote>
<p>先来个暴力法，直接AC</p>
<p>但是线性复杂度明显不能直接使用自带的排序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximumGap</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        nums.sort()</span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>):</span><br><span class="line">            max_len = max(max_len, nums[i + <span class="number">1</span>] - nums[i])</span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>

<p>查阅资料得知，排序算法中有三种是线性时间复杂度的，基数排序，桶排序，计数排序</p>
<p>这里我选用的是基数排序，总的来说是O(d*N)，约等于O(N)</p>
<p>这个算法不难 但是要能想得到</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximumGap</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        max_digit = <span class="number">0</span></span><br><span class="line">        max_num = max(nums)</span><br><span class="line">        <span class="keyword">while</span> max_num &gt; <span class="number">0</span>:</span><br><span class="line">            max_num = max_num // <span class="number">10</span></span><br><span class="line">            max_digit += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(max_digit):</span><br><span class="line">            tmp = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">            tmp_digit = <span class="number">10</span> ** i</span><br><span class="line">            tmp_nums = []</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line"></span><br><span class="line">                radix = nums[j] // tmp_digit % <span class="number">10</span></span><br><span class="line">                tmp[radix].append(nums[j])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> a <span class="keyword">in</span> tmp:</span><br><span class="line">                <span class="keyword">for</span> b <span class="keyword">in</span> a:</span><br><span class="line">                    tmp_nums.append(b)</span><br><span class="line"></span><br><span class="line">            nums = tmp_nums</span><br><span class="line">        </span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>):</span><br><span class="line">            max_len = max(max_len, nums[i + <span class="number">1</span>] - nums[i])</span><br><span class="line">        <span class="keyword">return</span> max_len</span><br></pre></td></tr></table></figure>

<h4 id="15-分数到小数"><a href="#15-分数到小数" class="headerlink" title="15. 分数到小数"></a>15. 分数到小数</h4><p>给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以字</p>
<p>符串形式返回小数。</p>
<p>如果小数部分为循环小数，则将循环的部分括在括号内。</p>
<blockquote>
<p>原题：<a href="https://leetcode-cn.com/problems/fraction-to-recurring-decimal/" target="_blank" rel="external nofollow noopener noreferrer">166. 分数到小数</a></p>
<p>难度：中等</p>
</blockquote>
<p>碰到这种数学问题，可以在纸上多写一个用例</p>
<p>这道题就是记录除数即可，当除数重复出现意味着余数都是一样的</p>
<p>定义一个hash表记录除数和它出现的位置 在这个位置插入一个(就可以了</p>
<p>需要注意的是边界问题 比如正负值 python的divmod或者//都是取整的 所以先判断正负值然后拿绝对值去计算 去除可能出现的四舍五入情况</p>
<p>然后就是0的情况</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fractionToDecimal</span><span class="params">(self, numerator: int, denominator: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> denominator == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">        <span class="keyword">if</span> numerator == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> str(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> (numerator &gt; <span class="number">0</span>) ^ (denominator &gt; <span class="number">0</span>):</span><br><span class="line">            res.append(<span class="string">'-'</span>)</span><br><span class="line">        numerator, denominator = abs(numerator), abs(denominator)</span><br><span class="line">        iv, fv = divmod(numerator, denominator)</span><br><span class="line">        res.append(str(iv))</span><br><span class="line">        <span class="keyword">if</span> fv == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">''</span>.join(res)</span><br><span class="line">        res.append(<span class="string">'.'</span>)</span><br><span class="line">        hashmap = &#123;fv: len(res)&#125;</span><br><span class="line">        <span class="keyword">while</span> fv:</span><br><span class="line">            fv *= <span class="number">10</span></span><br><span class="line">            iv, fv = divmod(fv, denominator)</span><br><span class="line">            res.append(str(iv))</span><br><span class="line">            <span class="keyword">if</span> fv <span class="keyword">in</span> hashmap:</span><br><span class="line">                res.insert(hashmap[fv], <span class="string">'('</span>)</span><br><span class="line">                res.append(<span class="string">')'</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashmap[fv] = len(res)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(res)</span><br></pre></td></tr></table></figure>

<h4 id="16-实现-Trie-前缀树"><a href="#16-实现-Trie-前缀树" class="headerlink" title="16. 实现 Trie (前缀树)"></a>16. 实现 Trie (前缀树)</h4><p>实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。</p>
<blockquote>
<p>原题：<a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/" target="_blank" rel="external nofollow noopener noreferrer">208. 实现 Trie (前缀树)</a></p>
<p>难度：中等</p>
</blockquote>
<p><img data-src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/pics/IMG_20200316_102415.jpg" alt></p>
<p>前缀树就是类似搜索引擎的东西, 主要思路就是用hash字典来快速检索每个单词是否存在，需注意的是search和startsWith的区别，需要用一个*<em>终止符号</em>来判断是否是一个完整的单词</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.trie = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, word: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Inserts a word into the trie.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        node = self.trie</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> node:</span><br><span class="line">                node[w] = &#123;&#125;</span><br><span class="line">            node = node[w]</span><br><span class="line">        node[<span class="string">'#'</span>] = <span class="string">'#'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, word: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns if the word is in the trie.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        node = self.trie</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            node = node[w]</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'#'</span> <span class="keyword">in</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startsWith</span><span class="params">(self, prefix: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns if there is any word in the trie that starts with the given prefix.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        node = self.trie</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> prefix:</span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            node = node[w]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = Trie()</span></span><br><span class="line"><span class="comment"># obj.insert(word)</span></span><br><span class="line"><span class="comment"># param_2 = obj.search(word)</span></span><br><span class="line"><span class="comment"># param_3 = obj.startsWith(prefix)</span></span><br></pre></td></tr></table></figure>

<p>修改版，一个空根节点，将是否结束从一个占位字符串改为属性</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.child = &#123;&#125;</span><br><span class="line">        self.is_end = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.root = TrieNode()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, word: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Inserts a word into the trie.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        node = self.root</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> node.child:</span><br><span class="line">                node.child[w] = TrieNode()</span><br><span class="line">            node = node.child[w]</span><br><span class="line">        node.is_end = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, word: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns if the word is in the trie.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        node = self.root</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> node.child:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            node = node.child[w]</span><br><span class="line">        <span class="keyword">if</span> node.is_end:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startsWith</span><span class="params">(self, prefix: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns if there is any word in the trie that starts with the given prefix.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        node = self.root</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> prefix:</span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> node.child:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            node = node.child[w]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your Trie object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = Trie()</span></span><br><span class="line"><span class="comment"># obj.insert(word)</span></span><br><span class="line"><span class="comment"># param_2 = obj.search(word)</span></span><br><span class="line"><span class="comment"># param_3 = obj.startsWith(prefix)</span></span><br></pre></td></tr></table></figure>

<h4 id="17-连接词"><a href="#17-连接词" class="headerlink" title="17. 连接词"></a>17. 连接词</h4><p>给定一个不含重复单词的列表，编写一个程序，返回给定单词列表中所有的连接词。</p>
<p>连接词的定义为:一个字符串完全是由至少两个给定数组中的单词组成的。</p>
<blockquote>
<p>原题：<a href="https://leetcode-cn.com/problems/concatenated-words/" target="_blank" rel="external nofollow noopener noreferrer">472. 连接词</a></p>
<p>难度：困难</p>
</blockquote>
<p>使用上一题写的前缀树，用深度搜索找到一个单词，然后再从根节点开始搜索</p>
<p>“catsdogcats”这个单词截至到cat是可以的，但是s开头并没有，所以再往下搜索到cats再继续裁切，此题需要记忆这个判定方式</p>
<p>另外，这里的前缀树与上一题不太一样，这里应该更好，因为是一棵树，根节点为空，上一题是多棵树，如果以上一题数据结构来解，会出现无线递归的问题，原因在<code>if &#39;#&#39; in node:</code>, 因为只要有一个空字符串，这里就会一直进来。。。</p>
<p>还有就是加一个参数，代表这个单词是否由多个单词组成而不是自身字符串</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.child = &#123;&#125;</span><br><span class="line">        self.is_end = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, word_list)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.root = TrieNode()</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> word_list:</span><br><span class="line">            <span class="keyword">if</span> word:</span><br><span class="line">                self.insert(word)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, word: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Inserts a word into the trie.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        node = self.root</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> w <span class="keyword">not</span> <span class="keyword">in</span> node.child:</span><br><span class="line">                node.child[w] = TrieNode()</span><br><span class="line">            node = node.child[w]</span><br><span class="line">        node.is_end = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findAllConcatenatedWordsInADict</span><span class="params">(self, words)</span>:</span></span><br><span class="line">        t = Trie(words)</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node, i, w, has_cut)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> i == len(w):</span><br><span class="line">                <span class="keyword">return</span> node.is_end <span class="keyword">and</span> has_cut</span><br><span class="line">            <span class="keyword">if</span> node.is_end:</span><br><span class="line">                <span class="keyword">if</span> dfs(t.root, i, w, <span class="literal">True</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> w[i] <span class="keyword">not</span> <span class="keyword">in</span> node.child:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> dfs(node.child[w[i]], i + <span class="number">1</span>, w, has_cut)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">            <span class="keyword">if</span> dfs(t.root, <span class="number">0</span>, w, <span class="literal">False</span>):</span><br><span class="line">                res.append(w)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h4 id="18-滑动窗口中位数"><a href="#18-滑动窗口中位数" class="headerlink" title="18. 滑动窗口中位数"></a>18. 滑动窗口中位数</h4><p>中位数是有序序列最中间的那个数。如果序列的大小是偶数，则没有最中间的数;此时中位数是最中间的两个数的平均数。</p>
<blockquote>
<p>原题：<a href="https://leetcode-cn.com/problems/sliding-window-median/" target="_blank" rel="external nofollow noopener noreferrer">480. 滑动窗口中位数</a></p>
<p>难度：困难</p>
</blockquote>
<p>暴力法，竟然AC了。。。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">medianSlidingWindow</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[float]:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        l, r = <span class="number">0</span>, k</span><br><span class="line">        res = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> r &lt;= n:</span><br><span class="line">            tmp = nums[l:r]</span><br><span class="line">            tmp.sort()</span><br><span class="line">            tmp_r = k - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                res.append(tmp[tmp_r // <span class="number">2</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                mid_num = (tmp[tmp_r // <span class="number">2</span>] + tmp[tmp_r // <span class="number">2</span> + <span class="number">1</span>]) / <span class="number">2</span></span><br><span class="line">                res.append(mid_num)</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>稍微修改了一下，减少空间复杂度和代码复杂度</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">medianSlidingWindow</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[float]:</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>: <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        window = sorted(nums[<span class="number">0</span>:k])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k, len(nums) + <span class="number">1</span>):</span><br><span class="line">            ans.append((window[k // <span class="number">2</span>] + window[(k - <span class="number">1</span>) // <span class="number">2</span>]) / <span class="number">2.0</span>)</span><br><span class="line">            <span class="keyword">if</span> i == len(nums): <span class="keyword">break</span></span><br><span class="line">            index = bisect.bisect_left(window, nums[i - k])</span><br><span class="line">            window.pop(index)      </span><br><span class="line">            bisect.insort_left(window, nums[i])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

<p>官方实例是用两个堆来实现，类似<code>295. 数据流的中位数</code></p>
<h4 id="19-祖玛游戏"><a href="#19-祖玛游戏" class="headerlink" title="19. 祖玛游戏"></a>19. 祖玛游戏</h4><p>回忆一下祖玛游戏。现在桌上有一串球，颜色有红色(R)，黄色(Y)，蓝色 (B)，绿色(G)，还有白色(W)。 现在你手里也有几个球。<br>每一次，你可以从手里的球选一个，然后把这个球插入到一串球中的某个位置 上(包括最左端，最右端)。接着，如果有出现三个或者三个以上颜色相同的 球相连的话，就把它们移除掉。重复这一步骤直到桌上所有的球都被移除。<br>找到插入并可以移除掉桌上所有球所需的最少的球数。如果不能移除桌上所有 的球，输出 -1 。</p>
<blockquote>
<p>原题：<a href="https://leetcode-cn.com/problems/zuma-game/" target="_blank" rel="external nofollow noopener noreferrer">488. 祖玛游戏</a></p>
<p>难度：困难</p>
<p>标签：dfs</p>
</blockquote>
<p>首先是这么写的，使用剪枝法，在每一个重复球最后加上球，然后用clear方法来剪枝，但是这个测试用例过不了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;RRWWRRBBRR&quot;</span><br><span class="line">&quot;WB&quot;</span><br></pre></td></tr></table></figure>

<p>以下方式会返回<code>-1</code>，最后剩一个<code>RR</code></p>
<p>但是是可以解出来的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RRWWRRBBRR-&gt;RRWWRRBBR(W)R-&gt;RRWWRRBB(B)R(W)R-&gt;RRWWRRR(W)R-&gt;RRWW(W)R-&gt;RRR-&gt;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>所以不能剪枝了，必须要每一个方法都要兼顾到</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMinStep</span><span class="params">(self, board: str, hand: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="comment"># 'RBYYBBBRRB'  =&gt;  'RBYYRRB'</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">clear</span><span class="params">(b)</span>:</span></span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; len(b):</span><br><span class="line">                j = i</span><br><span class="line">                <span class="keyword">while</span> j &lt; len(b) <span class="keyword">and</span> b[j] == b[i]:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> j - i &gt;= <span class="number">3</span>:</span><br><span class="line">                    b = b[:i] + b[j:]</span><br><span class="line">                    i = <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(b, h)</span>:</span></span><br><span class="line">            n = len(b)</span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            max_ball, i, j = float(<span class="string">'inf'</span>), <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; n:</span><br><span class="line">                <span class="keyword">while</span> j &lt; n <span class="keyword">and</span> b[j] == b[i]:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                balls = <span class="number">3</span> - (j - i)</span><br><span class="line">                color = b[i]</span><br><span class="line">                <span class="keyword">if</span> h[color] &gt;= balls:</span><br><span class="line">                    nb = clear(b[:j] + color * balls + b[j:])</span><br><span class="line">                    h[color] -= balls</span><br><span class="line">                    r = dfs(nb, h)</span><br><span class="line">                    <span class="comment"># 深度搜索结果不是-1</span></span><br><span class="line">                    <span class="keyword">if</span> r != <span class="number">-1</span>:</span><br><span class="line">                        max_ball = min(max_ball, r + balls)</span><br><span class="line">                    h[color] += balls</span><br><span class="line">                i = j</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> max_ball <span class="keyword">if</span> max_ball != float(<span class="string">'inf'</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(board, Counter(hand))</span><br></pre></td></tr></table></figure>

<p>正确方法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMinStep</span><span class="params">(self, board: str, hand: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(b, h)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> b:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            n, max_ball, i, j = len(b), float(<span class="string">'inf'</span>), <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; n:</span><br><span class="line">                <span class="keyword">while</span> j &lt; n <span class="keyword">and</span> b[i] == b[j]:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                balls = <span class="number">3</span> - (j - i)</span><br><span class="line">                color = b[i]</span><br><span class="line">                <span class="keyword">if</span> h[color] &gt;= balls:</span><br><span class="line">                    balls = max(<span class="number">0</span>, balls)</span><br><span class="line">                    h[color] -= balls</span><br><span class="line">                    r = dfs(b[:i] + b[j:], h)</span><br><span class="line">                    <span class="keyword">if</span> r &gt;= <span class="number">0</span>:</span><br><span class="line">                        max_ball = min(max_ball, r + balls)</span><br><span class="line">                    h[color] += balls</span><br><span class="line">                i = j</span><br><span class="line">            <span class="keyword">return</span> max_ball <span class="keyword">if</span> max_ball != float(<span class="string">'inf'</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(board, Counter(hand))</span><br></pre></td></tr></table></figure>



<h4 id="20-摘樱桃"><a href="#20-摘樱桃" class="headerlink" title="20. 摘樱桃"></a>20. 摘樱桃</h4><p>一个N x N的网格(grid) 代表了一块樱桃地，每个格子由以下三种数字的一种来表示：</p>
<p>0 表示这个格子是空的，所以你可以穿过它。<br>1 表示这个格子里装着一个樱桃，你可以摘到樱桃然后穿过它。<br>-1 表示这个格子里有荆棘，挡着你的路。<br>你的任务是在遵守下列规则的情况下，尽可能的摘到最多樱桃：</p>
<p>从位置 (0, 0) 出发，最后到达 (N-1, N-1) ，只能向下或向右走，并且只能穿越有效的格子（即只可以穿过值为0或者1的格子）；<br>当到达 (N-1, N-1) 后，你要继续走，直到返回到 (0, 0) ，只能向上或向左走，并且只能穿越有效的格子；<br>当你经过一个格子且这个格子包含一个樱桃时，你将摘到樱桃并且这个格子会变成空的（值变为0）；<br>如果在 (0, 0) 和 (N-1, N-1) 之间不存在一条可经过的路径，则没有任何一个樱桃能被摘到。</p>
<blockquote>
<p>原题：<a href="https://leetcode-cn.com/problems/cherry-pickup/" target="_blank" rel="external nofollow noopener noreferrer">741. 摘樱桃</a></p>
<p>难度： 困难</p>
<p>标签：dp</p>
</blockquote>
<p>一筹莫展，去花花酱找题解</p>
<p>三维的动态规划</p>
<p>时间复杂度和空间复杂度都是O(N^3)</p>
<p>抽象成两个人从右下角终点同时往左上起点走，坐标是(x1,y1)和(x2,y2)，由于是同时走，所以可以降维，y2=x1+y1-x2</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cherryPickup</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        n = len(grid)</span><br><span class="line">        dp = [[[float(<span class="string">'-inf'</span>)] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(x1, y1, x2)</span>:</span></span><br><span class="line">            y2 = x1 + y1 - x2</span><br><span class="line">            <span class="keyword">if</span> x1 &lt; <span class="number">0</span> <span class="keyword">or</span> x2 &lt; <span class="number">0</span> <span class="keyword">or</span> y1 &lt; <span class="number">0</span> <span class="keyword">or</span> y2 &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> grid[x1][y1] &lt; <span class="number">0</span> <span class="keyword">or</span> grid[x2][y2] &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> x1 == <span class="number">0</span> <span class="keyword">and</span> y1 == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> grid[x1][y1]</span><br><span class="line">            <span class="keyword">if</span> dp[x1][y1][x2] != float(<span class="string">'-inf'</span>):</span><br><span class="line">                <span class="keyword">return</span> dp[x1][y1][x2]</span><br><span class="line">            </span><br><span class="line">            res = max(</span><br><span class="line">                        max(helper(x1 - <span class="number">1</span>, y1, x2 - <span class="number">1</span>), helper(x1, y1 - <span class="number">1</span>, x2)),</span><br><span class="line">                        max(helper(x1, y1 - <span class="number">1</span>, x2 - <span class="number">1</span>), helper(x1 - <span class="number">1</span>, y1, x2))   </span><br><span class="line">                )</span><br><span class="line">            <span class="keyword">if</span> res &lt; <span class="number">0</span>:</span><br><span class="line">                dp[x1][y1][x2] = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += grid[x1][y1]</span><br><span class="line">                <span class="keyword">if</span> x1 != x2:</span><br><span class="line">                    res += grid[x2][y2]</span><br><span class="line">                dp[x1][y1][x2] = res</span><br><span class="line">            <span class="keyword">return</span> dp[x1][y1][x2]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(<span class="number">0</span>, helper(n - <span class="number">1</span>, n - <span class="number">1</span>, n - <span class="number">1</span>))</span><br></pre></td></tr></table></figure>



<h4 id="21-自除数"><a href="#21-自除数" class="headerlink" title="21. 自除数"></a>21. 自除数</h4><p>自除数 是指可以被它包含的每一位数除尽的数。</p>
<p>例如，128 是一个自除数，因为 128 % 1 == 0，128 % 2 == 0，128 % 8 == 0。</p>
<p>还有，自除数不允许包含 0 。</p>
<p>给定上边界和下边界数字，输出一个列表，列表的元素是边界（含边界）内所有的自除数。</p>
<blockquote>
<p>原题：<a href="https://leetcode-cn.com/problems/self-dividing-numbers/" target="_blank" rel="external nofollow noopener noreferrer">728. 自除数</a></p>
<p>难度：简单</p>
<p>标签：数学</p>
</blockquote>
<p>暴力法开搞，一个是改成字符串进行匹配，一个用数学除数和余数进行匹配</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">selfDividingNumbers</span><span class="params">(self, left: int, right: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="comment"># 改成字符串</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper1</span><span class="params">(num)</span>:</span></span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> list(str(num)):</span><br><span class="line">                <span class="keyword">if</span> n == <span class="string">'0'</span> <span class="keyword">or</span> num % int(n) != <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 数学运算</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper2</span><span class="params">(num)</span>:</span></span><br><span class="line">            tmp = num</span><br><span class="line">            <span class="keyword">while</span> tmp &gt; <span class="number">0</span>:</span><br><span class="line">                n = tmp % <span class="number">10</span></span><br><span class="line">                <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> num % n != <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                tmp = tmp // <span class="number">10</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> range(left, right + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> helper2(num):</span><br><span class="line">                res.append(num)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



<h4 id="22-回文系列"><a href="#22-回文系列" class="headerlink" title="22. 回文系列"></a>22. 回文系列</h4><p>原来的22题是 <a href="https://leetcode-cn.com/problems/count-different-palindromic-subsequences/" target="_blank" rel="external nofollow noopener noreferrer">730. 统计不同回文子字符串</a>  难度困难，由于只有几道题解，且需要三维dp，所以暂时放在一边，记录下回文系列</p>
<blockquote>
<p>原题：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="external nofollow noopener noreferrer">5. 最长回文子串</a> <a href="https://leetcode-cn.com/problems/palindrome-number/" target="_blank" rel="external nofollow noopener noreferrer">9. 回文数</a> <a href="https://leetcode-cn.com/problems/palindromic-substrings/" target="_blank" rel="external nofollow noopener noreferrer">647. 回文子串</a></p>
<p>难度：中等  简单  中等</p>
</blockquote>
<h5 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a>5. 最长回文子串</h5><p>中心扩展方法，需要分别奇数和偶数不同的下标</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        <span class="comment"># 两个情况 偶数和奇数</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(index, is_odd=False)</span>:</span></span><br><span class="line">            l = index - <span class="number">1</span> <span class="keyword">if</span> is_odd <span class="keyword">else</span> index</span><br><span class="line">            r = index + <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &gt;= <span class="number">0</span> <span class="keyword">and</span> r &lt; n:</span><br><span class="line">                <span class="keyword">if</span> s[l] == s[r]:</span><br><span class="line">                    l -= <span class="number">1</span></span><br><span class="line">                    r += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">return</span> s[l+<span class="number">1</span>:r]</span><br><span class="line"></span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>):</span><br><span class="line">            odd, even = helper(i, <span class="literal">True</span>), helper(i)</span><br><span class="line">            tmp = odd <span class="keyword">if</span> len(odd) &gt; len(even) <span class="keyword">else</span> even</span><br><span class="line">            <span class="keyword">if</span> len(res) &lt; len(tmp):</span><br><span class="line">                res = tmp</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>动态规划  必须掌握</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line">        max_len, res = <span class="number">1</span>, s[<span class="number">0</span>]</span><br><span class="line">        dp = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            dp[i][i] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(j):</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                    <span class="keyword">if</span> j - i &lt; <span class="number">3</span>:</span><br><span class="line">                        dp[i][j] = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> dp[i][j]:</span><br><span class="line">                    <span class="keyword">if</span> j - i + <span class="number">1</span> &gt; max_len:</span><br><span class="line">                        max_len = j - i</span><br><span class="line">                        res = s[i:j + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h5 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9. 回文数"></a>9. 回文数</h5><p>数学方法来解即可  可以缩短时间复杂度从N到logN，在于翻转的数字大于等于去掉尾部的源数字即可对比了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt;= x &lt; <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> x % <span class="number">10</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        new_x = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x &gt; new_x:</span><br><span class="line">            new_x = x % <span class="number">10</span> + <span class="number">10</span> * new_x</span><br><span class="line">            x //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> new_x // <span class="number">10</span> == x <span class="keyword">or</span> new_x == x</span><br></pre></td></tr></table></figure>

<h5 id="674-回文子串"><a href="#674-回文子串" class="headerlink" title="674. 回文子串"></a>674. 回文子串</h5><p>跟第5题一模一样，就是换个返回值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countSubstrings</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        dp = [[<span class="literal">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            dp[i][i] = <span class="literal">True</span></span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(j):</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j]:</span><br><span class="line">                    <span class="keyword">if</span> j - i &lt; <span class="number">3</span>:</span><br><span class="line">                        dp[i][j] = <span class="literal">True</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">if</span> dp[i][j] <span class="keyword">is</span> <span class="literal">True</span>:</span><br><span class="line">                        res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/blog/posts/99a22ef9/" rel="bookmark">HTTP基础知识</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/blog/posts/b8ccf74b/" rel="bookmark">python复习笔记</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/blog/posts/e255a10a/" rel="bookmark">计算机网络</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/blog/posts/2bbf7755/" rel="bookmark">题目一</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="/blog/posts/103f59fc/" rel="bookmark">题目二</a></div>
    </li>
  </ul>

        <div class="reward-container">
  <div>打赏一杯咖啡</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/blog/images/wechatpay.jpg" alt="vissssa 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/blog/images/alipay.jpg" alt="vissssa 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>vissssa
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://vissssa.gitee.io/blog/posts/efbabf5a/" title="30道经典算法面试题">https://vissssa.gitee.io/blog/posts/efbabf5a/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/en" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/blog/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
              <a href="/blog/tags/leetcode/" rel="tag"># leetcode</a>
              <a href="/blog/tags/interview/" rel="tag"># interview</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/blog/posts/a667b194/" rel="prev" title="mock与单元测试">
      <i class="fa fa-chevron-left"></i> mock与单元测试
    </a></div>
      <div class="post-nav-item">
    <a href="/blog/posts/2a049014/" rel="next" title="芝士披萨">
      芝士披萨 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-无重复字符的最长子串"><span class="nav-number">1.</span> <span class="nav-text">1. 无重复字符的最长子串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-整数反转"><span class="nav-number">2.</span> <span class="nav-text">2. 整数反转</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-字符串转换整数-atoi"><span class="nav-number">3.</span> <span class="nav-text">3. 字符串转换整数 (atoi)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-盛最多水的容器"><span class="nav-number">4.</span> <span class="nav-text">4. 盛最多水的容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-最长公共前缀"><span class="nav-number">5.</span> <span class="nav-text">5. 最长公共前缀</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-搜索插入位置"><span class="nav-number">6.</span> <span class="nav-text">6. 搜索插入位置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-跳跃游戏"><span class="nav-number">7.</span> <span class="nav-text">7. 跳跃游戏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-旋转图像"><span class="nav-number">8.</span> <span class="nav-text">8. 旋转图像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-二叉树的层次遍历"><span class="nav-number">9.</span> <span class="nav-text">9. 二叉树的层次遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-只出现一次的数字"><span class="nav-number">10.</span> <span class="nav-text">10. 只出现一次的数字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-只出现一次的数字-II"><span class="nav-number">11.</span> <span class="nav-text">11. 只出现一次的数字 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-排序链表"><span class="nav-number">12.</span> <span class="nav-text">12. 排序链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-寻找峰值"><span class="nav-number">13.</span> <span class="nav-text">13. 寻找峰值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-最大间距"><span class="nav-number">14.</span> <span class="nav-text">14. 最大间距</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-分数到小数"><span class="nav-number">15.</span> <span class="nav-text">15. 分数到小数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16-实现-Trie-前缀树"><span class="nav-number">16.</span> <span class="nav-text">16. 实现 Trie (前缀树)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#17-连接词"><span class="nav-number">17.</span> <span class="nav-text">17. 连接词</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-滑动窗口中位数"><span class="nav-number">18.</span> <span class="nav-text">18. 滑动窗口中位数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-祖玛游戏"><span class="nav-number">19.</span> <span class="nav-text">19. 祖玛游戏</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#20-摘樱桃"><span class="nav-number">20.</span> <span class="nav-text">20. 摘樱桃</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#21-自除数"><span class="nav-number">21.</span> <span class="nav-text">21. 自除数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#22-回文系列"><span class="nav-number">22.</span> <span class="nav-text">22. 回文系列</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-最长回文子串"><span class="nav-number">22.1.</span> <span class="nav-text">5. 最长回文子串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#9-回文数"><span class="nav-number">22.2.</span> <span class="nav-text">9. 回文数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#674-回文子串"><span class="nav-number">22.3.</span> <span class="nav-text">674. 回文子串</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="vissssa" src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/hexo/%E5%A4%B4%E5%83%8F%E5%8E%8B%E7%BC%A9%E7%89%88.jpg">
  <p class="site-author-name" itemprop="name">vissssa</p>
  <div class="site-description" itemprop="description">python, flask, linux, 架构, 生活, 科技</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives/">
        
          <span class="site-state-item-count">40</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">40</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/vissssa" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;vissssa" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:vissssa@163.com" title="E-Mail → mailto:vissssa@163.com" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/vissssa" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;vissssa" rel="external nofollow noopener noreferrer" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/en" class="cc-opacity" rel="external nofollow noopener noreferrer" target="_blank"><img src="/blog/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        
  <div class="beian"><a href="http://www.beian.miit.gov.cn/" rel="external nofollow noopener noreferrer" target="_blank">皖ICP备18020261号 </a>
      <img src="https://vissssa-imgs-1252712312.cos.ap-shanghai.myqcloud.com/hexo/%E5%A4%87%E6%A1%88%E5%9B%BE%E6%A0%87.png" style="display: inline-block;"><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=%E7%9A%96ICP%E5%A4%8718020261%E5%8F%B7" rel="external nofollow noopener noreferrer" target="_blank">1 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">vissssa</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">275k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">7:38</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="external nofollow noopener noreferrer" target="_blank">Hexo</a> 强力驱动 v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="external nofollow noopener noreferrer" target="_blank">NexT.Gemini</a> v7.7.1
  </div>

<div>
<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("11/06/2019 00:00:00");
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);
</script>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/pisces.js"></script>


<script src="/blog/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.getAttribute('pjax') !== null) {
      script.setAttribute('pjax', '');
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  
  <script pjax>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/blog/js/local-search.js"></script>













    <div id="pjax">
  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'c1fac73c19ac8f8c6e87',
      clientSecret: '2191820fd1c7bbd5c3dc9b6a1de97ace50a87e6c',
      repo        : 'blog',
      owner       : 'vissssa',
      admin       : ['vissssa'],
      id          : 'c73c3cf1656f4d20d76059447737e6ca',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

    </div>
</body>
</html>
